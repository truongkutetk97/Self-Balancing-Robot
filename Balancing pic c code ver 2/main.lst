CCS PCM C Compiler, Version 5.015, 5967               16-Dec-18 04:32

               Filename:   D:\ProgramFile\Github\Self-Balancing-Robot\Balancing pic c code ver 2\main.lst

               ROM used:   5448 words (67%)
                           Largest free fragment is 2048
               RAM used:   207 (56%) at main() level
                           291 (79%) worst case
               Stack used: 5 locations (3 in main + 2 for interrupts)
               Stack size: 8

*
0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.3
0028:  GOTO   02B
0029:  BTFSC  0B.0
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   1A2
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   1F5
....................  
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  MOVLW  80
0059:  BTFSS  03.1
005A:  GOTO   060
005B:  BSF    03.5
005C:  BSF    03.6
005D:  XORWF  29,F
005E:  BCF    03.5
005F:  BCF    03.6
0060:  BSF    03.5
0061:  BSF    03.6
0062:  CLRF   2E
0063:  CLRF   2F
0064:  MOVF   25,W
0065:  MOVWF  2D
0066:  MOVF   29,W
0067:  XORWF  2D,F
0068:  MOVF   24,W
0069:  BTFSC  03.2
006A:  GOTO   14F
006B:  MOVWF  2C
006C:  MOVWF  77
006D:  MOVF   28,W
006E:  BTFSC  03.2
006F:  GOTO   158
0070:  SUBWF  2C,F
0071:  BTFSC  03.2
0072:  GOTO   0F4
0073:  BTFSS  03.0
0074:  GOTO   0B2
0075:  MOVF   29,W
0076:  MOVWF  32
0077:  BSF    32.7
0078:  MOVF   2A,W
0079:  MOVWF  31
007A:  MOVF   2B,W
007B:  MOVWF  30
007C:  CLRF   2F
007D:  BCF    03.0
007E:  RRF    32,F
007F:  RRF    31,F
0080:  RRF    30,F
0081:  RRF    2F,F
0082:  DECFSZ 2C,F
0083:  GOTO   07C
0084:  BTFSS  2D.7
0085:  GOTO   089
0086:  BSF    2E.0
0087:  GOTO   16C
0088:  BCF    2E.0
0089:  BCF    2C.0
008A:  BSF    2E.4
008B:  MOVLW  A7
008C:  MOVWF  04
008D:  BSF    03.7
008E:  GOTO   181
008F:  BCF    2E.4
0090:  BTFSC  2D.7
0091:  GOTO   09C
0092:  BTFSS  2C.0
0093:  GOTO   0A7
0094:  RRF    32,F
0095:  RRF    31,F
0096:  RRF    30,F
0097:  RRF    2F,F
0098:  INCF   77,F
0099:  BTFSC  03.2
009A:  GOTO   167
009B:  GOTO   0A7
009C:  BTFSC  32.7
009D:  GOTO   0AA
009E:  BCF    03.0
009F:  RLF    2F,F
00A0:  RLF    30,F
00A1:  RLF    31,F
00A2:  RLF    32,F
00A3:  DECF   77,F
00A4:  BTFSC  03.2
00A5:  GOTO   167
00A6:  GOTO   09C
00A7:  BSF    2E.6
00A8:  GOTO   114
00A9:  BCF    2E.6
00AA:  MOVF   25,W
00AB:  MOVWF  2D
00AC:  BTFSS  2D.7
00AD:  GOTO   0B0
00AE:  BSF    32.7
00AF:  GOTO   160
00B0:  BCF    32.7
00B1:  GOTO   160
00B2:  MOVF   28,W
00B3:  MOVWF  2C
00B4:  MOVWF  77
00B5:  MOVF   24,W
00B6:  SUBWF  2C,F
00B7:  MOVF   25,W
00B8:  MOVWF  32
00B9:  BSF    32.7
00BA:  MOVF   26,W
00BB:  MOVWF  31
00BC:  MOVF   27,W
00BD:  MOVWF  30
00BE:  CLRF   2F
00BF:  BCF    03.0
00C0:  RRF    32,F
00C1:  RRF    31,F
00C2:  RRF    30,F
00C3:  RRF    2F,F
00C4:  DECFSZ 2C,F
00C5:  GOTO   0BE
00C6:  BTFSS  2D.7
00C7:  GOTO   0CB
00C8:  BSF    2E.1
00C9:  GOTO   16C
00CA:  BCF    2E.1
00CB:  BCF    2C.0
00CC:  BSF    2E.5
00CD:  MOVLW  AB
00CE:  MOVWF  04
00CF:  BSF    03.7
00D0:  GOTO   181
00D1:  BCF    2E.5
00D2:  BTFSC  2D.7
00D3:  GOTO   0DE
00D4:  BTFSS  2C.0
00D5:  GOTO   0E9
00D6:  RRF    32,F
00D7:  RRF    31,F
00D8:  RRF    30,F
00D9:  RRF    2F,F
00DA:  INCF   77,F
00DB:  BTFSC  03.2
00DC:  GOTO   167
00DD:  GOTO   0E9
00DE:  BTFSC  32.7
00DF:  GOTO   0EC
00E0:  BCF    03.0
00E1:  RLF    2F,F
00E2:  RLF    30,F
00E3:  RLF    31,F
00E4:  RLF    32,F
00E5:  DECF   77,F
00E6:  BTFSC  03.2
00E7:  GOTO   167
00E8:  GOTO   0DE
00E9:  BSF    2E.7
00EA:  GOTO   114
00EB:  BCF    2E.7
00EC:  MOVF   29,W
00ED:  MOVWF  2D
00EE:  BTFSS  2D.7
00EF:  GOTO   0F2
00F0:  BSF    32.7
00F1:  GOTO   160
00F2:  BCF    32.7
00F3:  GOTO   160
00F4:  MOVF   29,W
00F5:  MOVWF  32
00F6:  BSF    32.7
00F7:  MOVF   2A,W
00F8:  MOVWF  31
00F9:  MOVF   2B,W
00FA:  MOVWF  30
00FB:  BTFSS  2D.7
00FC:  GOTO   101
00FD:  BCF    32.7
00FE:  BSF    2E.2
00FF:  GOTO   16C
0100:  BCF    2E.2
0101:  CLRF   2F
0102:  BCF    2C.0
0103:  MOVLW  A7
0104:  MOVWF  04
0105:  BSF    03.7
0106:  GOTO   181
0107:  BTFSC  2D.7
0108:  GOTO   12A
0109:  MOVF   25,W
010A:  MOVWF  2D
010B:  BTFSS  2C.0
010C:  GOTO   114
010D:  RRF    32,F
010E:  RRF    31,F
010F:  RRF    30,F
0110:  RRF    2F,F
0111:  INCF   77,F
0112:  BTFSC  03.2
0113:  GOTO   167
0114:  BTFSS  2F.7
0115:  GOTO   125
0116:  INCF   30,F
0117:  BTFSS  03.2
0118:  GOTO   125
0119:  INCF   31,F
011A:  BTFSS  03.2
011B:  GOTO   125
011C:  INCF   32,F
011D:  BTFSS  03.2
011E:  GOTO   125
011F:  RRF    32,F
0120:  RRF    31,F
0121:  RRF    30,F
0122:  INCF   77,F
0123:  BTFSC  03.2
0124:  GOTO   167
0125:  BTFSC  2E.6
0126:  GOTO   0A9
0127:  BTFSC  2E.7
0128:  GOTO   0EB
0129:  GOTO   149
012A:  MOVLW  80
012B:  XORWF  32,F
012C:  BTFSS  32.7
012D:  GOTO   132
012E:  GOTO   16C
012F:  MOVF   29,W
0130:  MOVWF  2D
0131:  GOTO   13F
0132:  MOVF   25,W
0133:  MOVWF  2D
0134:  MOVF   32,F
0135:  BTFSS  03.2
0136:  GOTO   13F
0137:  MOVF   31,F
0138:  BTFSS  03.2
0139:  GOTO   13F
013A:  MOVF   30,F
013B:  BTFSS  03.2
013C:  GOTO   13F
013D:  CLRF   77
013E:  GOTO   160
013F:  BTFSC  32.7
0140:  GOTO   149
0141:  BCF    03.0
0142:  RLF    2F,F
0143:  RLF    30,F
0144:  RLF    31,F
0145:  RLF    32,F
0146:  DECFSZ 77,F
0147:  GOTO   13F
0148:  GOTO   167
0149:  BTFSS  2D.7
014A:  GOTO   14D
014B:  BSF    32.7
014C:  GOTO   160
014D:  BCF    32.7
014E:  GOTO   160
014F:  MOVF   28,W
0150:  MOVWF  77
0151:  MOVF   29,W
0152:  MOVWF  32
0153:  MOVF   2A,W
0154:  MOVWF  31
0155:  MOVF   2B,W
0156:  MOVWF  30
0157:  GOTO   160
0158:  MOVF   24,W
0159:  MOVWF  77
015A:  MOVF   25,W
015B:  MOVWF  32
015C:  MOVF   26,W
015D:  MOVWF  31
015E:  MOVF   27,W
015F:  MOVWF  30
0160:  MOVF   32,W
0161:  MOVWF  78
0162:  MOVF   31,W
0163:  MOVWF  79
0164:  MOVF   30,W
0165:  MOVWF  7A
0166:  GOTO   19F
0167:  CLRF   77
0168:  CLRF   78
0169:  CLRF   79
016A:  CLRF   7A
016B:  GOTO   19F
016C:  CLRF   2F
016D:  COMF   30,F
016E:  COMF   31,F
016F:  COMF   32,F
0170:  COMF   2F,F
0171:  INCF   2F,F
0172:  BTFSS  03.2
0173:  GOTO   17A
0174:  INCF   30,F
0175:  BTFSS  03.2
0176:  GOTO   17A
0177:  INCF   31,F
0178:  BTFSC  03.2
0179:  INCF   32,F
017A:  BTFSC  2E.0
017B:  GOTO   088
017C:  BTFSC  2E.1
017D:  GOTO   0CA
017E:  BTFSC  2E.2
017F:  GOTO   100
0180:  GOTO   12F
0181:  MOVF   00,W
0182:  ADDWF  30,F
0183:  BTFSS  03.0
0184:  GOTO   18B
0185:  INCF   31,F
0186:  BTFSS  03.2
0187:  GOTO   18B
0188:  INCF   32,F
0189:  BTFSC  03.2
018A:  BSF    2C.0
018B:  DECF   04,F
018C:  MOVF   00,W
018D:  ADDWF  31,F
018E:  BTFSS  03.0
018F:  GOTO   193
0190:  INCF   32,F
0191:  BTFSC  03.2
0192:  BSF    2C.0
0193:  DECF   04,F
0194:  MOVF   00,W
0195:  BTFSS  00.7
0196:  XORLW  80
0197:  ADDWF  32,F
0198:  BTFSC  03.0
0199:  BSF    2C.0
019A:  BTFSC  2E.4
019B:  GOTO   08F
019C:  BTFSC  2E.5
019D:  GOTO   0D1
019E:  GOTO   107
019F:  BCF    03.5
01A0:  BCF    03.6
01A1:  RETURN
*
023B:  DATA 20,05
023C:  DATA 20,1E
023D:  DATA 20,12
023E:  DATA 25,17
023F:  DATA 32,33
0240:  DATA 24,10
0241:  DATA A4,12
0242:  DATA 2E,19
0243:  DATA 66,12
0244:  DATA 20,12
0245:  DATA 25,17
0246:  DATA 32,33
0247:  DATA 24,10
0248:  DATA 3E,10
0249:  DATA 00,00
*
03F3:  MOVLW  8E
03F4:  MOVWF  77
03F5:  BSF    03.6
03F6:  MOVF   48,W
03F7:  MOVWF  78
03F8:  MOVF   47,W
03F9:  MOVWF  79
03FA:  CLRF   7A
03FB:  BTFSS  48.7
03FC:  GOTO   402
03FD:  COMF   78,F
03FE:  COMF   79,F
03FF:  INCF   79,F
0400:  BTFSC  03.2
0401:  INCF   78,F
0402:  MOVF   78,F
0403:  BTFSS  03.2
0404:  GOTO   40F
0405:  MOVF   79,W
0406:  MOVWF  78
0407:  CLRF   79
0408:  MOVLW  08
0409:  SUBWF  77,F
040A:  MOVF   78,F
040B:  BTFSS  03.2
040C:  GOTO   40F
040D:  CLRF   77
040E:  GOTO   418
040F:  BCF    03.0
0410:  BTFSC  78.7
0411:  GOTO   416
0412:  RLF    79,F
0413:  RLF    78,F
0414:  DECF   77,F
0415:  GOTO   40F
0416:  BTFSS  48.7
0417:  BCF    78.7
0418:  BCF    03.6
0419:  RETURN
041A:  BSF    03.6
041B:  MOVF   6B,W
041C:  MOVWF  6E
041D:  BSF    03.5
041E:  MOVF   11,W
041F:  BCF    03.5
0420:  XORWF  6E,F
0421:  BTFSS  6E.7
0422:  GOTO   428
0423:  BCF    03.2
0424:  BCF    03.0
0425:  BTFSC  6B.7
0426:  BSF    03.0
0427:  GOTO   463
0428:  MOVF   6B,W
0429:  MOVWF  6E
042A:  BSF    03.5
042B:  MOVF   10,W
042C:  BCF    03.5
042D:  MOVWF  6F
042E:  MOVF   6A,W
042F:  SUBWF  6F,F
0430:  BTFSC  03.2
0431:  GOTO   438
0432:  BTFSS  6E.7
0433:  GOTO   463
0434:  MOVF   03,W
0435:  XORLW  01
0436:  MOVWF  03
0437:  GOTO   463
0438:  BSF    03.5
0439:  MOVF   11,W
043A:  BCF    03.5
043B:  MOVWF  6F
043C:  MOVF   6B,W
043D:  SUBWF  6F,F
043E:  BTFSC  03.2
043F:  GOTO   446
0440:  BTFSS  6E.7
0441:  GOTO   463
0442:  MOVF   03,W
0443:  XORLW  01
0444:  MOVWF  03
0445:  GOTO   463
0446:  BSF    03.5
0447:  MOVF   12,W
0448:  BCF    03.5
0449:  MOVWF  6F
044A:  MOVF   6C,W
044B:  SUBWF  6F,F
044C:  BTFSC  03.2
044D:  GOTO   454
044E:  BTFSS  6E.7
044F:  GOTO   463
0450:  MOVF   03,W
0451:  XORLW  01
0452:  MOVWF  03
0453:  GOTO   463
0454:  BSF    03.5
0455:  MOVF   13,W
0456:  BCF    03.5
0457:  MOVWF  6F
0458:  MOVF   6D,W
0459:  SUBWF  6F,F
045A:  BTFSC  03.2
045B:  GOTO   462
045C:  BTFSS  6E.7
045D:  GOTO   463
045E:  MOVF   03,W
045F:  XORLW  01
0460:  MOVWF  03
0461:  GOTO   463
0462:  BCF    03.0
0463:  BCF    03.6
0464:  RETURN
0465:  BSF    03.5
0466:  BSF    03.6
0467:  MOVF   10,W
0468:  BTFSC  03.2
0469:  GOTO   52C
046A:  MOVWF  1C
046B:  MOVF   14,W
046C:  BTFSC  03.2
046D:  GOTO   52C
046E:  SUBWF  1C,F
046F:  BTFSS  03.0
0470:  GOTO   476
0471:  MOVLW  7F
0472:  ADDWF  1C,F
0473:  BTFSC  03.0
0474:  GOTO   52C
0475:  GOTO   47C
0476:  MOVLW  81
0477:  SUBWF  1C,F
0478:  BTFSS  03.0
0479:  GOTO   52C
047A:  BTFSC  03.2
047B:  GOTO   52C
047C:  MOVF   1C,W
047D:  MOVWF  77
047E:  CLRF   78
047F:  CLRF   79
0480:  CLRF   7A
0481:  CLRF   1B
0482:  MOVF   11,W
0483:  MOVWF  1A
0484:  BSF    1A.7
0485:  MOVF   12,W
0486:  MOVWF  19
0487:  MOVF   13,W
0488:  MOVWF  18
0489:  MOVLW  19
048A:  MOVWF  1C
048B:  MOVF   17,W
048C:  SUBWF  18,F
048D:  BTFSC  03.0
048E:  GOTO   49F
048F:  MOVLW  01
0490:  SUBWF  19,F
0491:  BTFSC  03.0
0492:  GOTO   49F
0493:  SUBWF  1A,F
0494:  BTFSC  03.0
0495:  GOTO   49F
0496:  SUBWF  1B,F
0497:  BTFSC  03.0
0498:  GOTO   49F
0499:  INCF   1B,F
049A:  INCF   1A,F
049B:  INCF   19,F
049C:  MOVF   17,W
049D:  ADDWF  18,F
049E:  GOTO   4D1
049F:  MOVF   16,W
04A0:  SUBWF  19,F
04A1:  BTFSC  03.0
04A2:  GOTO   4BA
04A3:  MOVLW  01
04A4:  SUBWF  1A,F
04A5:  BTFSC  03.0
04A6:  GOTO   4BA
04A7:  SUBWF  1B,F
04A8:  BTFSC  03.0
04A9:  GOTO   4BA
04AA:  INCF   1B,F
04AB:  INCF   1A,F
04AC:  MOVF   16,W
04AD:  ADDWF  19,F
04AE:  MOVF   17,W
04AF:  ADDWF  18,F
04B0:  BTFSS  03.0
04B1:  GOTO   4D1
04B2:  INCF   19,F
04B3:  BTFSS  03.2
04B4:  GOTO   4D1
04B5:  INCF   1A,F
04B6:  BTFSS  03.2
04B7:  GOTO   4D1
04B8:  INCF   1B,F
04B9:  GOTO   4D1
04BA:  MOVF   15,W
04BB:  IORLW  80
04BC:  SUBWF  1A,F
04BD:  BTFSC  03.0
04BE:  GOTO   4D0
04BF:  MOVLW  01
04C0:  SUBWF  1B,F
04C1:  BTFSC  03.0
04C2:  GOTO   4D0
04C3:  INCF   1B,F
04C4:  MOVF   15,W
04C5:  IORLW  80
04C6:  ADDWF  1A,F
04C7:  MOVF   16,W
04C8:  ADDWF  19,F
04C9:  BTFSS  03.0
04CA:  GOTO   4AE
04CB:  INCF   1A,F
04CC:  BTFSS  03.2
04CD:  GOTO   4AE
04CE:  INCF   1B,F
04CF:  GOTO   4AE
04D0:  BSF    7A.0
04D1:  DECFSZ 1C,F
04D2:  GOTO   4D4
04D3:  GOTO   4DF
04D4:  BCF    03.0
04D5:  RLF    18,F
04D6:  RLF    19,F
04D7:  RLF    1A,F
04D8:  RLF    1B,F
04D9:  BCF    03.0
04DA:  RLF    7A,F
04DB:  RLF    79,F
04DC:  RLF    78,F
04DD:  RLF    1D,F
04DE:  GOTO   48B
04DF:  BTFSS  1D.0
04E0:  GOTO   4E7
04E1:  BCF    03.0
04E2:  RRF    78,F
04E3:  RRF    79,F
04E4:  RRF    7A,F
04E5:  RRF    1D,F
04E6:  GOTO   4EA
04E7:  DECF   77,F
04E8:  BTFSC  03.2
04E9:  GOTO   52C
04EA:  BTFSC  1D.7
04EB:  GOTO   513
04EC:  BCF    03.0
04ED:  RLF    18,F
04EE:  RLF    19,F
04EF:  RLF    1A,F
04F0:  RLF    1B,F
04F1:  MOVF   17,W
04F2:  SUBWF  18,F
04F3:  BTFSC  03.0
04F4:  GOTO   4FF
04F5:  MOVLW  01
04F6:  SUBWF  19,F
04F7:  BTFSC  03.0
04F8:  GOTO   4FF
04F9:  SUBWF  1A,F
04FA:  BTFSC  03.0
04FB:  GOTO   4FF
04FC:  SUBWF  1B,F
04FD:  BTFSS  03.0
04FE:  GOTO   522
04FF:  MOVF   16,W
0500:  SUBWF  19,F
0501:  BTFSC  03.0
0502:  GOTO   50A
0503:  MOVLW  01
0504:  SUBWF  1A,F
0505:  BTFSC  03.0
0506:  GOTO   50A
0507:  SUBWF  1B,F
0508:  BTFSS  03.0
0509:  GOTO   522
050A:  MOVF   15,W
050B:  IORLW  80
050C:  SUBWF  1A,F
050D:  BTFSC  03.0
050E:  GOTO   513
050F:  MOVLW  01
0510:  SUBWF  1B,F
0511:  BTFSS  03.0
0512:  GOTO   522
0513:  INCF   7A,F
0514:  BTFSS  03.2
0515:  GOTO   522
0516:  INCF   79,F
0517:  BTFSS  03.2
0518:  GOTO   522
0519:  INCF   78,F
051A:  BTFSS  03.2
051B:  GOTO   522
051C:  INCF   77,F
051D:  BTFSC  03.2
051E:  GOTO   52C
051F:  RRF    78,F
0520:  RRF    79,F
0521:  RRF    7A,F
0522:  MOVF   11,W
0523:  MOVWF  1C
0524:  MOVF   15,W
0525:  XORWF  1C,F
0526:  BTFSS  1C.7
0527:  GOTO   52A
0528:  BSF    78.7
0529:  GOTO   530
052A:  BCF    78.7
052B:  GOTO   530
052C:  CLRF   77
052D:  CLRF   78
052E:  CLRF   79
052F:  CLRF   7A
0530:  BCF    03.5
0531:  BCF    03.6
0532:  RETURN
0533:  BSF    03.5
0534:  BSF    03.6
0535:  MOVF   10,W
0536:  BTFSC  03.2
0537:  GOTO   5A5
0538:  MOVWF  18
0539:  MOVF   14,W
053A:  BTFSC  03.2
053B:  GOTO   5A5
053C:  ADDWF  18,F
053D:  BTFSC  03.0
053E:  GOTO   546
053F:  MOVLW  7F
0540:  SUBWF  18,F
0541:  BTFSS  03.0
0542:  GOTO   5A5
0543:  BTFSC  03.2
0544:  GOTO   5A5
0545:  GOTO   54A
0546:  MOVLW  81
0547:  ADDWF  18,F
0548:  BTFSC  03.0
0549:  GOTO   5A5
054A:  MOVF   18,W
054B:  MOVWF  77
054C:  CLRF   78
054D:  CLRF   79
054E:  CLRF   7A
054F:  MOVF   11,W
0550:  MOVWF  1C
0551:  BSF    1C.7
0552:  MOVF   12,W
0553:  MOVWF  1B
0554:  MOVF   13,W
0555:  MOVWF  1A
0556:  MOVLW  18
0557:  MOVWF  18
0558:  CLRF   19
0559:  BTFSS  1A.0
055A:  GOTO   573
055B:  MOVF   17,W
055C:  ADDWF  7A,F
055D:  BTFSS  03.0
055E:  GOTO   565
055F:  INCF   79,F
0560:  BTFSS  03.2
0561:  GOTO   565
0562:  INCF   78,F
0563:  BTFSC  03.2
0564:  BSF    19.7
0565:  MOVF   16,W
0566:  ADDWF  79,F
0567:  BTFSS  03.0
0568:  GOTO   56C
0569:  INCF   78,F
056A:  BTFSC  03.2
056B:  BSF    19.7
056C:  MOVF   15,W
056D:  MOVWF  12
056E:  BSF    12.7
056F:  MOVF   12,W
0570:  ADDWF  78,F
0571:  BTFSC  03.0
0572:  BSF    19.7
0573:  RLF    19,F
0574:  RRF    78,F
0575:  RRF    79,F
0576:  RRF    7A,F
0577:  RRF    1C,F
0578:  RRF    1B,F
0579:  RRF    1A,F
057A:  BCF    03.0
057B:  DECFSZ 18,F
057C:  GOTO   558
057D:  MOVLW  01
057E:  ADDWF  77,F
057F:  BTFSC  03.0
0580:  GOTO   5A5
0581:  BTFSC  78.7
0582:  GOTO   58A
0583:  RLF    1C,F
0584:  RLF    7A,F
0585:  RLF    79,F
0586:  RLF    78,F
0587:  DECF   77,F
0588:  BTFSC  03.2
0589:  GOTO   5A5
058A:  BTFSS  1C.7
058B:  GOTO   59B
058C:  INCF   7A,F
058D:  BTFSS  03.2
058E:  GOTO   59B
058F:  INCF   79,F
0590:  BTFSS  03.2
0591:  GOTO   59B
0592:  INCF   78,F
0593:  BTFSS  03.2
0594:  GOTO   59B
0595:  RRF    78,F
0596:  RRF    79,F
0597:  RRF    7A,F
0598:  INCF   77,F
0599:  BTFSC  03.2
059A:  GOTO   5A5
059B:  MOVF   11,W
059C:  MOVWF  19
059D:  MOVF   15,W
059E:  XORWF  19,F
059F:  BTFSS  19.7
05A0:  GOTO   5A3
05A1:  BSF    78.7
05A2:  GOTO   5A9
05A3:  BCF    78.7
05A4:  GOTO   5A9
05A5:  CLRF   77
05A6:  CLRF   78
05A7:  CLRF   79
05A8:  CLRF   7A
05A9:  BCF    03.5
05AA:  BCF    03.6
05AB:  RETURN
*
073F:  BSF    0A.0
0740:  BSF    0A.1
0741:  BSF    0A.2
0742:  ADDWF  02,F
0743:  GOTO   696
0744:  GOTO   6A7
0745:  GOTO   6E1
0746:  GOTO   729
*
075E:  MOVLW  10
075F:  BSF    03.6
0760:  MOVWF  4B
0761:  CLRF   77
0762:  CLRF   7A
0763:  RRF    48,F
0764:  RRF    47,F
0765:  BTFSS  03.0
0766:  GOTO   76D
0767:  MOVF   49,W
0768:  ADDWF  77,F
0769:  BTFSC  03.0
076A:  INCF   7A,F
076B:  MOVF   4A,W
076C:  ADDWF  7A,F
076D:  RRF    7A,F
076E:  RRF    77,F
076F:  RRF    79,F
0770:  RRF    78,F
0771:  DECFSZ 4B,F
0772:  GOTO   763
0773:  BCF    03.6
0774:  RETURN
0775:  MOVLW  8E
0776:  MOVWF  77
0777:  BSF    03.6
0778:  MOVF   44,W
0779:  MOVWF  78
077A:  MOVF   43,W
077B:  MOVWF  79
077C:  CLRF   7A
077D:  MOVF   78,F
077E:  BTFSS  03.2
077F:  GOTO   78A
0780:  MOVF   79,W
0781:  MOVWF  78
0782:  CLRF   79
0783:  MOVLW  08
0784:  SUBWF  77,F
0785:  MOVF   78,F
0786:  BTFSS  03.2
0787:  GOTO   78A
0788:  CLRF   77
0789:  GOTO   792
078A:  BCF    03.0
078B:  BTFSC  78.7
078C:  GOTO   791
078D:  RLF    79,F
078E:  RLF    78,F
078F:  DECF   77,F
0790:  GOTO   78A
0791:  BCF    78.7
0792:  BCF    03.6
0793:  BCF    0A.3
0794:  BSF    0A.4
0795:  GOTO   38F (RETURN)
0796:  MOVF   0B,W
0797:  BSF    03.6
0798:  MOVWF  44
0799:  BCF    03.6
079A:  BCF    0B.7
079B:  BSF    03.5
079C:  BSF    03.6
079D:  BSF    0C.7
079E:  BSF    0C.0
079F:  NOP
07A0:  NOP
07A1:  BCF    03.5
07A2:  BTFSS  44.7
07A3:  GOTO   7A7
07A4:  BCF    03.6
07A5:  BSF    0B.7
07A6:  BSF    03.6
07A7:  BTFSC  03.0
07A8:  GOTO   7CF
07A9:  MOVF   0C,W
07AA:  ANDLW  7F
07AB:  MOVWF  44
07AC:  MOVF   0D,W
07AD:  MOVWF  45
07AE:  MOVF   0F,W
07AF:  MOVWF  46
07B0:  MOVF   44,W
07B1:  BCF    03.6
07B2:  BTFSS  0C.4
07B3:  GOTO   7B2
07B4:  MOVWF  19
07B5:  BSF    03.6
07B6:  MOVF   45,W
07B7:  MOVWF  0D
07B8:  MOVF   46,W
07B9:  MOVWF  0F
07BA:  BCF    03.6
07BB:  MOVF   0B,W
07BC:  BSF    03.6
07BD:  MOVWF  47
07BE:  BCF    03.6
07BF:  BCF    0B.7
07C0:  BSF    03.5
07C1:  BSF    03.6
07C2:  BSF    0C.7
07C3:  BSF    0C.0
07C4:  NOP
07C5:  NOP
07C6:  BCF    03.5
07C7:  BTFSS  47.7
07C8:  GOTO   7CC
07C9:  BCF    03.6
07CA:  BSF    0B.7
07CB:  BSF    03.6
07CC:  DECFSZ 43,F
07CD:  GOTO   7CF
07CE:  GOTO   7EA
07CF:  RLF    0C,W
07D0:  RLF    0E,W
07D1:  ANDLW  7F
07D2:  MOVWF  44
07D3:  MOVF   0D,W
07D4:  MOVWF  45
07D5:  MOVF   0F,W
07D6:  MOVWF  46
07D7:  MOVF   44,W
07D8:  BCF    03.6
07D9:  BTFSS  0C.4
07DA:  GOTO   7D9
07DB:  MOVWF  19
07DC:  BSF    03.6
07DD:  MOVF   45,W
07DE:  MOVWF  0D
07DF:  MOVF   46,W
07E0:  MOVWF  0F
07E1:  INCF   0D,F
07E2:  BTFSC  03.2
07E3:  INCF   0F,F
07E4:  BCF    03.0
07E5:  DECFSZ 43,F
07E6:  GOTO   7E8
07E7:  GOTO   7EA
07E8:  BCF    03.6
07E9:  GOTO   796
07EA:  BCF    03.6
07EB:  RETURN
*
0C25:  BTFSC  03.1
0C26:  GOTO   42A
0C27:  MOVLW  58
0C28:  MOVWF  04
0C29:  BSF    03.7
0C2A:  CLRF   77
0C2B:  CLRF   78
0C2C:  CLRF   79
0C2D:  CLRF   7A
0C2E:  BSF    03.6
0C2F:  CLRF   58
0C30:  CLRF   59
0C31:  CLRF   5A
0C32:  CLRF   5B
0C33:  MOVF   57,W
0C34:  IORWF  56,W
0C35:  IORWF  55,W
0C36:  IORWF  54,W
0C37:  BTFSC  03.2
0C38:  GOTO   469
0C39:  MOVLW  20
0C3A:  MOVWF  5C
0C3B:  BCF    03.0
0C3C:  RLF    50,F
0C3D:  RLF    51,F
0C3E:  RLF    52,F
0C3F:  RLF    53,F
0C40:  RLF    58,F
0C41:  RLF    59,F
0C42:  RLF    5A,F
0C43:  RLF    5B,F
0C44:  MOVF   57,W
0C45:  SUBWF  5B,W
0C46:  BTFSS  03.2
0C47:  GOTO   452
0C48:  MOVF   56,W
0C49:  SUBWF  5A,W
0C4A:  BTFSS  03.2
0C4B:  GOTO   452
0C4C:  MOVF   55,W
0C4D:  SUBWF  59,W
0C4E:  BTFSS  03.2
0C4F:  GOTO   452
0C50:  MOVF   54,W
0C51:  SUBWF  58,W
0C52:  BTFSS  03.0
0C53:  GOTO   463
0C54:  MOVF   54,W
0C55:  SUBWF  58,F
0C56:  MOVF   55,W
0C57:  BTFSS  03.0
0C58:  INCFSZ 55,W
0C59:  SUBWF  59,F
0C5A:  MOVF   56,W
0C5B:  BTFSS  03.0
0C5C:  INCFSZ 56,W
0C5D:  SUBWF  5A,F
0C5E:  MOVF   57,W
0C5F:  BTFSS  03.0
0C60:  INCFSZ 57,W
0C61:  SUBWF  5B,F
0C62:  BSF    03.0
0C63:  RLF    77,F
0C64:  RLF    78,F
0C65:  RLF    79,F
0C66:  RLF    7A,F
0C67:  DECFSZ 5C,F
0C68:  GOTO   43B
0C69:  MOVF   58,W
0C6A:  MOVWF  00
0C6B:  INCF   04,F
0C6C:  MOVF   59,W
0C6D:  MOVWF  00
0C6E:  INCF   04,F
0C6F:  MOVF   5A,W
0C70:  MOVWF  00
0C71:  INCF   04,F
0C72:  MOVF   5B,W
0C73:  MOVWF  00
0C74:  BCF    03.6
0C75:  RETURN
0C76:  MOVF   04,W
0C77:  BSF    03.6
0C78:  MOVWF  48
0C79:  MOVF   47,W
0C7A:  MOVWF  4A
0C7B:  BTFSC  03.2
0C7C:  GOTO   4A2
0C7D:  MOVF   46,W
0C7E:  BSF    03.5
0C7F:  MOVWF  13
0C80:  BCF    03.5
0C81:  MOVF   45,W
0C82:  BSF    03.5
0C83:  MOVWF  12
0C84:  BCF    03.5
0C85:  MOVF   44,W
0C86:  BSF    03.5
0C87:  MOVWF  11
0C88:  BCF    03.5
0C89:  MOVF   43,W
0C8A:  BSF    03.5
0C8B:  MOVWF  10
0C8C:  CLRF   17
0C8D:  CLRF   16
0C8E:  MOVLW  20
0C8F:  MOVWF  15
0C90:  MOVLW  82
0C91:  MOVWF  14
0C92:  BCF    0A.3
0C93:  BCF    03.5
0C94:  BCF    03.6
0C95:  CALL   533
0C96:  BSF    0A.3
0C97:  MOVF   7A,W
0C98:  BSF    03.6
0C99:  MOVWF  46
0C9A:  MOVF   79,W
0C9B:  MOVWF  45
0C9C:  MOVF   78,W
0C9D:  MOVWF  44
0C9E:  MOVF   77,W
0C9F:  MOVWF  43
0CA0:  DECFSZ 4A,F
0CA1:  GOTO   47D
0CA2:  MOVF   46,W
0CA3:  MOVWF  53
0CA4:  MOVF   45,W
0CA5:  MOVWF  52
0CA6:  MOVF   44,W
0CA7:  MOVWF  51
0CA8:  MOVF   43,W
0CA9:  MOVWF  50
0CAA:  MOVF   50,W
0CAB:  SUBLW  B6
0CAC:  MOVWF  50
0CAD:  CLRF   7A
0CAE:  MOVF   51,W
0CAF:  MOVWF  54
0CB0:  BSF    51.7
0CB1:  BCF    03.0
0CB2:  RRF    51,F
0CB3:  RRF    52,F
0CB4:  RRF    53,F
0CB5:  RRF    7A,F
0CB6:  RRF    79,F
0CB7:  RRF    78,F
0CB8:  RRF    77,F
0CB9:  DECFSZ 50,F
0CBA:  GOTO   4B1
0CBB:  BTFSS  54.7
0CBC:  GOTO   4C8
0CBD:  COMF   77,F
0CBE:  COMF   78,F
0CBF:  COMF   79,F
0CC0:  COMF   7A,F
0CC1:  INCF   77,F
0CC2:  BTFSC  03.2
0CC3:  INCF   78,F
0CC4:  BTFSC  03.2
0CC5:  INCF   79,F
0CC6:  BTFSC  03.2
0CC7:  INCF   7A,F
0CC8:  MOVF   7A,W
0CC9:  MOVWF  46
0CCA:  MOVF   79,W
0CCB:  MOVWF  45
0CCC:  MOVF   78,W
0CCD:  MOVWF  44
0CCE:  MOVF   77,W
0CCF:  MOVWF  43
0CD0:  BTFSS  46.7
0CD1:  GOTO   4DF
0CD2:  DECF   48,F
0CD3:  BSF    48.5
0CD4:  COMF   43,F
0CD5:  COMF   44,F
0CD6:  COMF   45,F
0CD7:  COMF   46,F
0CD8:  INCF   43,F
0CD9:  BTFSC  03.2
0CDA:  INCF   44,F
0CDB:  BTFSC  03.2
0CDC:  INCF   45,F
0CDD:  BTFSC  03.2
0CDE:  INCF   46,F
0CDF:  MOVLW  3B
0CE0:  MOVWF  4F
0CE1:  MOVLW  9A
0CE2:  MOVWF  4E
0CE3:  MOVLW  CA
0CE4:  MOVWF  4D
0CE5:  CLRF   4C
0CE6:  MOVLW  0A
0CE7:  MOVWF  4A
0CE8:  MOVF   47,W
0CE9:  BTFSC  03.2
0CEA:  INCF   48,F
0CEB:  BSF    03.1
0CEC:  MOVLW  43
0CED:  MOVWF  04
0CEE:  BSF    03.7
0CEF:  MOVF   46,W
0CF0:  MOVWF  53
0CF1:  MOVF   45,W
0CF2:  MOVWF  52
0CF3:  MOVF   44,W
0CF4:  MOVWF  51
0CF5:  MOVF   43,W
0CF6:  MOVWF  50
0CF7:  MOVF   4F,W
0CF8:  MOVWF  57
0CF9:  MOVF   4E,W
0CFA:  MOVWF  56
0CFB:  MOVF   4D,W
0CFC:  MOVWF  55
0CFD:  MOVF   4C,W
0CFE:  MOVWF  54
0CFF:  BCF    03.6
0D00:  CALL   425
0D01:  MOVF   78,W
0D02:  MOVF   77,F
0D03:  BTFSS  03.2
0D04:  GOTO   51C
0D05:  BSF    03.6
0D06:  INCF   47,W
0D07:  SUBWF  4A,W
0D08:  BTFSS  03.2
0D09:  GOTO   50C
0D0A:  BCF    03.6
0D0B:  GOTO   51C
0D0C:  MOVF   48,W
0D0D:  BTFSC  03.2
0D0E:  GOTO   51F
0D0F:  ANDLW  0F
0D10:  SUBWF  4A,W
0D11:  BTFSC  03.2
0D12:  GOTO   515
0D13:  BTFSC  03.0
0D14:  GOTO   55B
0D15:  BTFSC  48.7
0D16:  GOTO   55B
0D17:  BTFSC  48.6
0D18:  GOTO   51F
0D19:  MOVLW  20
0D1A:  GOTO   554
0D1B:  BCF    03.6
0D1C:  MOVLW  20
0D1D:  BSF    03.6
0D1E:  ANDWF  48,F
0D1F:  BTFSS  48.5
0D20:  GOTO   530
0D21:  BCF    48.5
0D22:  MOVF   47,W
0D23:  BTFSS  03.2
0D24:  DECF   48,F
0D25:  MOVF   77,W
0D26:  MOVWF  48
0D27:  MOVLW  2D
0D28:  BCF    03.6
0D29:  BTFSS  0C.4
0D2A:  GOTO   529
0D2B:  MOVWF  19
0D2C:  BSF    03.6
0D2D:  MOVF   48,W
0D2E:  MOVWF  77
0D2F:  CLRF   48
0D30:  MOVF   47,W
0D31:  SUBWF  4A,W
0D32:  BTFSS  03.2
0D33:  GOTO   541
0D34:  MOVF   77,W
0D35:  MOVWF  48
0D36:  MOVLW  2E
0D37:  BCF    03.6
0D38:  BTFSS  0C.4
0D39:  GOTO   538
0D3A:  MOVWF  19
0D3B:  BSF    03.6
0D3C:  MOVF   48,W
0D3D:  MOVWF  77
0D3E:  MOVLW  20
0D3F:  ANDWF  48,F
0D40:  MOVLW  00
0D41:  MOVLW  30
0D42:  BTFSS  48.5
0D43:  GOTO   554
0D44:  BCF    48.5
0D45:  MOVF   47,W
0D46:  BTFSS  03.2
0D47:  DECF   48,F
0D48:  MOVF   77,W
0D49:  MOVWF  48
0D4A:  MOVLW  2D
0D4B:  BCF    03.6
0D4C:  BTFSS  0C.4
0D4D:  GOTO   54C
0D4E:  MOVWF  19
0D4F:  BSF    03.6
0D50:  MOVF   48,W
0D51:  MOVWF  77
0D52:  CLRF   48
0D53:  MOVLW  30
0D54:  ADDWF  77,F
0D55:  MOVF   77,W
0D56:  BCF    03.6
0D57:  BTFSS  0C.4
0D58:  GOTO   557
0D59:  MOVWF  19
0D5A:  BSF    03.6
0D5B:  BCF    03.1
0D5C:  MOVF   4F,W
0D5D:  MOVWF  53
0D5E:  MOVF   4E,W
0D5F:  MOVWF  52
0D60:  MOVF   4D,W
0D61:  MOVWF  51
0D62:  MOVF   4C,W
0D63:  MOVWF  50
0D64:  CLRF   57
0D65:  CLRF   56
0D66:  CLRF   55
0D67:  MOVLW  0A
0D68:  MOVWF  54
0D69:  BCF    03.6
0D6A:  CALL   425
0D6B:  MOVF   7A,W
0D6C:  BSF    03.6
0D6D:  MOVWF  4F
0D6E:  MOVF   79,W
0D6F:  MOVWF  4E
0D70:  MOVF   78,W
0D71:  MOVWF  4D
0D72:  MOVF   77,W
0D73:  MOVWF  4C
0D74:  DECFSZ 4A,F
0D75:  GOTO   4EB
0D76:  BCF    03.6
0D77:  RETURN
....................  
.................... #list 
....................  
.................... #include "MPU60500.c" 
.................... #define MPU6050_I2C_Wr(value) i2c_write(value)  
.................... #define MPU6050_I2C_Rd(value) i2c_read(value)  
.................... #define MPU6050_I2C_Stop() i2c_stop()  
.................... #define MPU6050_I2C_Start() i2c_start()         
....................  
....................  
.................... // 
.................... #define MPU6050_ADDRESS             0xD0 
.................... #define MPU6050_RA_XG_OFFS_TC       0x00  
.................... #define MPU6050_RA_YG_OFFS_TC       0x01  
.................... #define MPU6050_RA_ZG_OFFS_TC       0x02  
.................... #define MPU6050_RA_X_FINE_GAIN      0x03  
.................... #define MPU6050_RA_Y_FINE_GAIN      0x04  
.................... #define MPU6050_RA_Z_FINE_GAIN      0x05  
.................... #define MPU6050_RA_XA_OFFS_H        0x06  
.................... #define MPU6050_RA_XA_OFFS_L_TC     0x07 
.................... #define MPU6050_RA_YA_OFFS_H        0x08  
.................... #define MPU6050_RA_YA_OFFS_L_TC     0x09 
.................... #define MPU6050_RA_ZA_OFFS_H        0x0A  
.................... #define MPU6050_RA_ZA_OFFS_L_TC     0x0B 
.................... #define MPU6050_RA_XG_OFFS_USRH     0x13  
.................... #define MPU6050_RA_XG_OFFS_USRL     0x14 
.................... #define MPU6050_RA_YG_OFFS_USRH     0x15  
.................... #define MPU6050_RA_YG_OFFS_USRL     0x16 
.................... #define MPU6050_RA_ZG_OFFS_USRH     0x17  
.................... #define MPU6050_RA_ZG_OFFS_USRL     0x18 
.................... #define MPU6050_RA_SMPLRT_DIV       0x19 
.................... #define MPU6050_RA_CONFIG           0x1A 
.................... #define MPU6050_RA_GYRO_CONFIG      0x1B 
.................... #define MPU6050_RA_ACCEL_CONFIG     0x1C 
.................... #define MPU6050_RA_FF_THR           0x1D 
.................... #define MPU6050_RA_FF_DUR           0x1E 
.................... #define MPU6050_RA_MOT_THR          0x1F 
.................... #define MPU6050_RA_MOT_DUR          0x20 
.................... #define MPU6050_RA_ZRMOT_THR        0x21 
.................... #define MPU6050_RA_ZRMOT_DUR        0x22 
.................... #define MPU6050_RA_FIFO_EN          0x23 
.................... #define MPU6050_RA_I2C_MST_CTRL     0x24 
.................... #define MPU6050_RA_I2C_SLV0_ADDR    0x25 
.................... #define MPU6050_RA_I2C_SLV0_REG     0x26 
.................... #define MPU6050_RA_I2C_SLV0_CTRL    0x27 
.................... #define MPU6050_RA_I2C_SLV1_ADDR    0x28 
.................... #define MPU6050_RA_I2C_SLV1_REG     0x29 
.................... #define MPU6050_RA_I2C_SLV1_CTRL    0x2A 
.................... #define MPU6050_RA_I2C_SLV2_ADDR    0x2B 
.................... #define MPU6050_RA_I2C_SLV2_REG     0x2C 
.................... #define MPU6050_RA_I2C_SLV2_CTRL    0x2D 
.................... #define MPU6050_RA_I2C_SLV3_ADDR    0x2E 
.................... #define MPU6050_RA_I2C_SLV3_REG     0x2F 
.................... #define MPU6050_RA_I2C_SLV3_CTRL    0x30 
.................... #define MPU6050_RA_I2C_SLV4_ADDR    0x31 
.................... #define MPU6050_RA_I2C_SLV4_REG     0x32 
.................... #define MPU6050_RA_I2C_SLV4_DO      0x33 
.................... #define MPU6050_RA_I2C_SLV4_CTRL    0x34 
.................... #define MPU6050_RA_I2C_SLV4_DI      0x35 
.................... #define MPU6050_RA_I2C_MST_STATUS   0x36 
.................... #define MPU6050_RA_INT_PIN_CFG      0x37 
.................... #define MPU6050_RA_INT_ENABLE       0x38 
.................... #define MPU6050_RA_DMP_INT_STATUS   0x39 
.................... #define MPU6050_RA_INT_STATUS       0x3A 
.................... #define MPU6050_RA_ACCEL_XOUT_H     0x3B 
.................... #define MPU6050_RA_ACCEL_XOUT_L     0x3C 
.................... #define MPU6050_RA_ACCEL_YOUT_H     0x3D 
.................... #define MPU6050_RA_ACCEL_YOUT_L     0x3E 
.................... #define MPU6050_RA_ACCEL_ZOUT_H     0x3F 
.................... #define MPU6050_RA_ACCEL_ZOUT_L     0x40 
.................... #define MPU6050_RA_TEMP_OUT_H       0x41 
.................... #define MPU6050_RA_TEMP_OUT_L       0x42 
.................... #define MPU6050_RA_GYRO_XOUT_H      0x43 
.................... #define MPU6050_RA_GYRO_XOUT_L      0x44 
.................... #define MPU6050_RA_GYRO_YOUT_H      0x45 
.................... #define MPU6050_RA_GYRO_YOUT_L      0x46 
.................... #define MPU6050_RA_GYRO_ZOUT_H      0x47 
.................... #define MPU6050_RA_GYRO_ZOUT_L      0x48 
.................... #define MPU6050_RA_EXT_SENS_DATA_00 0x49 
.................... #define MPU6050_RA_EXT_SENS_DATA_01 0x4A 
.................... #define MPU6050_RA_EXT_SENS_DATA_02 0x4B 
.................... #define MPU6050_RA_EXT_SENS_DATA_03 0x4C 
.................... #define MPU6050_RA_EXT_SENS_DATA_04 0x4D 
.................... #define MPU6050_RA_EXT_SENS_DATA_05 0x4E 
.................... #define MPU6050_RA_EXT_SENS_DATA_06 0x4F 
.................... #define MPU6050_RA_EXT_SENS_DATA_07 0x50 
.................... #define MPU6050_RA_EXT_SENS_DATA_08 0x51 
.................... #define MPU6050_RA_EXT_SENS_DATA_09 0x52 
.................... #define MPU6050_RA_EXT_SENS_DATA_10 0x53 
.................... #define MPU6050_RA_EXT_SENS_DATA_11 0x54 
.................... #define MPU6050_RA_EXT_SENS_DATA_12 0x55 
.................... #define MPU6050_RA_EXT_SENS_DATA_13 0x56 
.................... #define MPU6050_RA_EXT_SENS_DATA_14 0x57 
.................... #define MPU6050_RA_EXT_SENS_DATA_15 0x58 
.................... #define MPU6050_RA_EXT_SENS_DATA_16 0x59 
.................... #define MPU6050_RA_EXT_SENS_DATA_17 0x5A 
.................... #define MPU6050_RA_EXT_SENS_DATA_18 0x5B 
.................... #define MPU6050_RA_EXT_SENS_DATA_19 0x5C 
.................... #define MPU6050_RA_EXT_SENS_DATA_20 0x5D 
.................... #define MPU6050_RA_EXT_SENS_DATA_21 0x5E 
.................... #define MPU6050_RA_EXT_SENS_DATA_22 0x5F 
.................... #define MPU6050_RA_EXT_SENS_DATA_23 0x60 
.................... #define MPU6050_RA_MOT_DETECT_STATUS    0x61 
.................... #define MPU6050_RA_I2C_SLV0_DO      0x63 
.................... #define MPU6050_RA_I2C_SLV1_DO      0x64 
.................... #define MPU6050_RA_I2C_SLV2_DO      0x65 
.................... #define MPU6050_RA_I2C_SLV3_DO      0x66 
.................... #define MPU6050_RA_I2C_MST_DELAY_CTRL   0x67 
.................... #define MPU6050_RA_SIGNAL_PATH_RESET    0x68 
.................... #define MPU6050_RA_MOT_DETECT_CTRL      0x69 
.................... #define MPU6050_RA_USER_CTRL        0x6A 
.................... #define MPU6050_RA_PWR_MGMT_1       0x6B 
.................... #define MPU6050_RA_PWR_MGMT_2       0x6C 
.................... #define MPU6050_RA_BANK_SEL         0x6D 
.................... #define MPU6050_RA_MEM_START_ADDR   0x6E 
.................... #define MPU6050_RA_MEM_R_W          0x6F 
.................... #define MPU6050_RA_DMP_CFG_1        0x70 
.................... #define MPU6050_RA_DMP_CFG_2        0x71 
.................... #define MPU6050_RA_FIFO_COUNTH      0x72 
.................... #define MPU6050_RA_FIFO_COUNTL      0x73 
.................... #define MPU6050_RA_FIFO_R_W         0x74 
.................... #define MPU6050_RA_WHO_AM_I         0x75 
....................  
.................... #use i2c(Master,Fast,sda=PIN_C4,scl=PIN_C3) 
*
024A:  MOVLW  08
024B:  MOVWF  78
024C:  NOP
024D:  BCF    07.3
024E:  BCF    2C.3
024F:  MOVF   2C,W
0250:  BSF    03.5
0251:  MOVWF  07
0252:  NOP
0253:  BCF    03.5
0254:  BSF    03.6
0255:  RLF    48,F
0256:  BCF    03.6
0257:  BCF    07.4
0258:  BTFSS  03.0
0259:  GOTO   260
025A:  BSF    2C.4
025B:  MOVF   2C,W
025C:  BSF    03.5
025D:  MOVWF  07
025E:  GOTO   264
025F:  BCF    03.5
0260:  BCF    2C.4
0261:  MOVF   2C,W
0262:  BSF    03.5
0263:  MOVWF  07
0264:  NOP
0265:  BCF    03.5
0266:  BSF    2C.3
0267:  MOVF   2C,W
0268:  BSF    03.5
0269:  MOVWF  07
026A:  BCF    03.5
026B:  BTFSS  07.3
026C:  GOTO   26B
026D:  DECFSZ 78,F
026E:  GOTO   24C
026F:  NOP
0270:  BCF    07.3
0271:  BCF    2C.3
0272:  MOVF   2C,W
0273:  BSF    03.5
0274:  MOVWF  07
0275:  NOP
0276:  BCF    03.5
0277:  BSF    2C.4
0278:  MOVF   2C,W
0279:  BSF    03.5
027A:  MOVWF  07
027B:  NOP
027C:  NOP
027D:  BCF    03.5
027E:  BSF    2C.3
027F:  MOVF   2C,W
0280:  BSF    03.5
0281:  MOVWF  07
0282:  BCF    03.5
0283:  BTFSS  07.3
0284:  GOTO   283
0285:  CLRF   78
0286:  NOP
0287:  BTFSC  07.4
0288:  BSF    78.0
0289:  BCF    07.3
028A:  BCF    2C.3
028B:  MOVF   2C,W
028C:  BSF    03.5
028D:  MOVWF  07
028E:  BCF    03.5
028F:  BCF    07.4
0290:  BCF    2C.4
0291:  MOVF   2C,W
0292:  BSF    03.5
0293:  MOVWF  07
0294:  BCF    03.5
0295:  RETURN
*
032A:  MOVLW  08
032B:  BSF    03.6
032C:  MOVWF  49
032D:  MOVF   77,W
032E:  MOVWF  4A
032F:  BCF    03.6
0330:  BSF    2C.4
0331:  MOVF   2C,W
0332:  BSF    03.5
0333:  MOVWF  07
0334:  NOP
0335:  BCF    03.5
0336:  BSF    2C.3
0337:  MOVF   2C,W
0338:  BSF    03.5
0339:  MOVWF  07
033A:  BCF    03.5
033B:  BTFSS  07.3
033C:  GOTO   33B
033D:  BTFSC  07.4
033E:  BSF    03.0
033F:  BTFSS  07.4
0340:  BCF    03.0
0341:  RLF    78,F
0342:  NOP
0343:  BCF    2C.3
0344:  MOVF   2C,W
0345:  BSF    03.5
0346:  MOVWF  07
0347:  BCF    03.5
0348:  BCF    07.3
0349:  BSF    03.6
034A:  DECFSZ 49,F
034B:  GOTO   32F
034C:  BCF    03.6
034D:  BSF    2C.4
034E:  MOVF   2C,W
034F:  BSF    03.5
0350:  MOVWF  07
0351:  NOP
0352:  BCF    03.5
0353:  BCF    07.4
0354:  BSF    03.6
0355:  MOVF   4A,W
0356:  BTFSC  03.2
0357:  GOTO   35F
0358:  BCF    03.6
0359:  BCF    2C.4
035A:  MOVF   2C,W
035B:  BSF    03.5
035C:  MOVWF  07
035D:  BCF    03.5
035E:  BSF    03.6
035F:  NOP
0360:  BCF    03.6
0361:  BSF    2C.3
0362:  MOVF   2C,W
0363:  BSF    03.5
0364:  MOVWF  07
0365:  BCF    03.5
0366:  BTFSS  07.3
0367:  GOTO   366
0368:  NOP
0369:  BCF    07.3
036A:  BCF    2C.3
036B:  MOVF   2C,W
036C:  BSF    03.5
036D:  MOVWF  07
036E:  NOP
036F:  BCF    03.5
0370:  BCF    07.4
0371:  BCF    2C.4
0372:  MOVF   2C,W
0373:  BSF    03.5
0374:  MOVWF  07
0375:  BCF    03.5
0376:  RETURN
.................... #use DELAY(clock=22118400) 
*
02D5:  MOVLW  43
02D6:  MOVWF  04
02D7:  BSF    03.7
02D8:  MOVF   00,W
02D9:  BTFSC  03.2
02DA:  GOTO   2E9
02DB:  MOVLW  07
02DC:  MOVWF  78
02DD:  CLRF   77
02DE:  DECFSZ 77,F
02DF:  GOTO   2DE
02E0:  DECFSZ 78,F
02E1:  GOTO   2DD
02E2:  MOVLW  2A
02E3:  MOVWF  77
02E4:  DECFSZ 77,F
02E5:  GOTO   2E4
02E6:  GOTO   2E7
02E7:  DECFSZ 00,F
02E8:  GOTO   2DB
02E9:  RETURN
....................  
.................... unsigned char MPU6050_Read(unsigned char address) 
....................    { 
....................    int8 Data;      
....................    MPU6050_I2C_Start();            
....................    MPU6050_I2C_Wr( MPU6050_ADDRESS );       
....................    MPU6050_I2C_Wr(address);     
....................    MPU6050_I2C_Start();           
....................    MPU6050_I2C_Wr( MPU6050_ADDRESS | 1 );   
....................    Data=MPU6050_I2C_Rd(0);         
....................     MPU6050_I2C_Stop();               
....................    return Data;    
....................    }   
.................... void Mpu6050_Write(unsigned char address,unsigned char Data) 
....................    { 
....................    MPU6050_I2C_Start();                
*
0296:  BSF    2C.4
0297:  MOVF   2C,W
0298:  BSF    03.5
0299:  MOVWF  07
029A:  NOP
029B:  BCF    03.5
029C:  BSF    2C.3
029D:  MOVF   2C,W
029E:  BSF    03.5
029F:  MOVWF  07
02A0:  NOP
02A1:  BCF    03.5
02A2:  BCF    07.4
02A3:  BCF    2C.4
02A4:  MOVF   2C,W
02A5:  BSF    03.5
02A6:  MOVWF  07
02A7:  NOP
02A8:  BCF    03.5
02A9:  BCF    07.3
02AA:  BCF    2C.3
02AB:  MOVF   2C,W
02AC:  BSF    03.5
02AD:  MOVWF  07
....................    MPU6050_I2C_Wr( MPU6050_ADDRESS );     
02AE:  MOVLW  D0
02AF:  BCF    03.5
02B0:  BSF    03.6
02B1:  MOVWF  48
02B2:  BCF    03.6
02B3:  CALL   24A
....................    MPU6050_I2C_Wr( address);    
02B4:  BSF    03.6
02B5:  MOVF   43,W
02B6:  MOVWF  48
02B7:  BCF    03.6
02B8:  CALL   24A
....................    MPU6050_I2C_Wr( Data);        
02B9:  BSF    03.6
02BA:  MOVF   44,W
02BB:  MOVWF  48
02BC:  BCF    03.6
02BD:  CALL   24A
....................    MPU6050_I2C_Stop();      
02BE:  BCF    2C.4
02BF:  MOVF   2C,W
02C0:  BSF    03.5
02C1:  MOVWF  07
02C2:  NOP
02C3:  BCF    03.5
02C4:  BSF    2C.3
02C5:  MOVF   2C,W
02C6:  BSF    03.5
02C7:  MOVWF  07
02C8:  BCF    03.5
02C9:  BTFSS  07.3
02CA:  GOTO   2C9
02CB:  NOP
02CC:  GOTO   2CD
02CD:  NOP
02CE:  BSF    2C.4
02CF:  MOVF   2C,W
02D0:  BSF    03.5
02D1:  MOVWF  07
02D2:  NOP
02D3:  BCF    03.5
02D4:  RETURN
....................    } 
....................  
.................... int16 Mpu6050_GetData(unsigned char address) 
*
0377:  BSF    03.6
0378:  CLRF   45
0379:  CLRF   44
037A:  CLRF   47
037B:  CLRF   46
.................... { 
....................    int16 H=0,L=0;     
....................    MPU6050_I2C_Start();        
037C:  BCF    03.6
037D:  BSF    2C.4
037E:  MOVF   2C,W
037F:  BSF    03.5
0380:  MOVWF  07
0381:  NOP
0382:  BCF    03.5
0383:  BSF    2C.3
0384:  MOVF   2C,W
0385:  BSF    03.5
0386:  MOVWF  07
0387:  NOP
0388:  BCF    03.5
0389:  BCF    07.4
038A:  BCF    2C.4
038B:  MOVF   2C,W
038C:  BSF    03.5
038D:  MOVWF  07
038E:  NOP
038F:  BCF    03.5
0390:  BCF    07.3
0391:  BCF    2C.3
0392:  MOVF   2C,W
0393:  BSF    03.5
0394:  MOVWF  07
....................    MPU6050_I2C_Wr( MPU6050_ADDRESS );       
0395:  MOVLW  D0
0396:  BCF    03.5
0397:  BSF    03.6
0398:  MOVWF  48
0399:  BCF    03.6
039A:  CALL   24A
....................    MPU6050_I2C_Wr(address);     
039B:  BSF    03.6
039C:  MOVF   43,W
039D:  MOVWF  48
039E:  BCF    03.6
039F:  CALL   24A
....................    MPU6050_I2C_Start();          
03A0:  BSF    2C.4
03A1:  MOVF   2C,W
03A2:  BSF    03.5
03A3:  MOVWF  07
03A4:  NOP
03A5:  BCF    03.5
03A6:  BSF    2C.3
03A7:  MOVF   2C,W
03A8:  BSF    03.5
03A9:  MOVWF  07
03AA:  NOP
03AB:  BCF    03.5
03AC:  BTFSS  07.3
03AD:  GOTO   3AC
03AE:  BCF    07.4
03AF:  BCF    2C.4
03B0:  MOVF   2C,W
03B1:  BSF    03.5
03B2:  MOVWF  07
03B3:  NOP
03B4:  BCF    03.5
03B5:  BCF    07.3
03B6:  BCF    2C.3
03B7:  MOVF   2C,W
03B8:  BSF    03.5
03B9:  MOVWF  07
....................    MPU6050_I2C_Wr( MPU6050_ADDRESS |1);    
03BA:  MOVLW  D1
03BB:  BCF    03.5
03BC:  BSF    03.6
03BD:  MOVWF  48
03BE:  BCF    03.6
03BF:  CALL   24A
....................    H=i2C_read();            
03C0:  MOVLW  01
03C1:  MOVWF  77
03C2:  CALL   32A
03C3:  BSF    03.6
03C4:  CLRF   45
03C5:  MOVF   78,W
03C6:  MOVWF  44
....................    L=i2C_read(0);          
03C7:  CLRF   77
03C8:  BCF    03.6
03C9:  CALL   32A
03CA:  BSF    03.6
03CB:  CLRF   47
03CC:  MOVF   78,W
03CD:  MOVWF  46
....................    MPU6050_I2C_Stop();           
03CE:  BCF    03.6
03CF:  BCF    2C.4
03D0:  MOVF   2C,W
03D1:  BSF    03.5
03D2:  MOVWF  07
03D3:  NOP
03D4:  BCF    03.5
03D5:  BSF    2C.3
03D6:  MOVF   2C,W
03D7:  BSF    03.5
03D8:  MOVWF  07
03D9:  BCF    03.5
03DA:  BTFSS  07.3
03DB:  GOTO   3DA
03DC:  NOP
03DD:  GOTO   3DE
03DE:  NOP
03DF:  BSF    2C.4
03E0:  MOVF   2C,W
03E1:  BSF    03.5
03E2:  MOVWF  07
03E3:  NOP
....................    return (H<<8)|L; 
03E4:  BCF    03.5
03E5:  BSF    03.6
03E6:  CLRF   48
03E7:  MOVF   48,W
03E8:  IORWF  46,W
03E9:  MOVWF  77
03EA:  MOVF   44,W
03EB:  IORWF  47,W
03EC:  MOVWF  7A
03ED:  MOVF   77,W
03EE:  MOVWF  78
03EF:  MOVF   7A,W
03F0:  MOVWF  79
03F1:  BCF    03.6
03F2:  RETURN
.................... }                                               
....................     
....................  
....................  
....................  
....................  
....................  
.................... void Mpu6050_Init() 
....................    { 
....................  
....................    Mpu6050_Write(MPU6050_RA_PWR_MGMT_1,0X80);  
*
02EA:  MOVLW  6B
02EB:  BSF    03.6
02EC:  MOVWF  43
02ED:  MOVLW  80
02EE:  MOVWF  44
02EF:  BCF    03.6
02F0:  CALL   296
....................    delay_ms(5); 
02F1:  MOVLW  05
02F2:  BSF    03.6
02F3:  MOVWF  43
02F4:  BCF    03.6
02F5:  CALL   2D5
....................    Mpu6050_Write(MPU6050_RA_PWR_MGMT_1, 0x00);  
02F6:  MOVLW  6B
02F7:  BSF    03.6
02F8:  MOVWF  43
02F9:  CLRF   44
02FA:  BCF    03.6
02FB:  CALL   296
....................    Mpu6050_Write(MPU6050_RA_SMPLRT_DIV 0x07);  //Set the sample rate to 1000Hz - 8kHz/(7+1) = 1000Hz 
02FC:  MOVLW  19
02FD:  BSF    03.6
02FE:  MOVWF  43
02FF:  MOVLW  07
0300:  MOVWF  44
0301:  BCF    03.6
0302:  CALL   296
....................    Mpu6050_Write(MPU6050_RA_CONFIG, 0x00);       
0303:  MOVLW  1A
0304:  BSF    03.6
0305:  MOVWF  43
0306:  CLRF   44
0307:  BCF    03.6
0308:  CALL   296
....................                                        
....................    Mpu6050_Write(MPU6050_RA_GYRO_CONFIG, 0x00);  
0309:  MOVLW  1B
030A:  BSF    03.6
030B:  MOVWF  43
030C:  CLRF   44
030D:  BCF    03.6
030E:  CALL   296
....................                                        
....................    Mpu6050_Write(MPU6050_RA_ACCEL_CONFIG, 0x00);  
030F:  MOVLW  1C
0310:  BSF    03.6
0311:  MOVWF  43
0312:  CLRF   44
0313:  BCF    03.6
0314:  CALL   296
....................                                       
....................    Mpu6050_Write(MPU6050_RA_USER_CTRL, 0x00);    
0315:  MOVLW  6A
0316:  BSF    03.6
0317:  MOVWF  43
0318:  CLRF   44
0319:  BCF    03.6
031A:  CALL   296
....................    Mpu6050_Write(MPU6050_RA_PWR_MGMT_1, 0x01);                          
031B:  MOVLW  6B
031C:  BSF    03.6
031D:  MOVWF  43
031E:  MOVLW  01
031F:  MOVWF  44
0320:  BCF    03.6
0321:  CALL   296
....................    delay_ms(10); 
0322:  MOVLW  0A
0323:  BSF    03.6
0324:  MOVWF  43
0325:  BCF    03.6
0326:  CALL   2D5
0327:  BCF    0A.3
0328:  BSF    0A.4
0329:  GOTO   092 (RETURN)
....................    } 
....................  
....................  
.................... #include "math.h" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
*
0800:  BSF    03.6
0801:  BCF    69.0
....................    flag = 0; 
0802:  BCF    69.1
....................    y = x; 
0803:  MOVF   5C,W
0804:  MOVWF  60
0805:  MOVF   5B,W
0806:  MOVWF  5F
0807:  MOVF   5A,W
0808:  MOVWF  5E
0809:  MOVF   59,W
080A:  MOVWF  5D
....................  
....................    if (x < 0) 
080B:  MOVF   5C,W
080C:  MOVWF  6D
080D:  MOVF   5B,W
080E:  MOVWF  6C
080F:  MOVF   5A,W
0810:  MOVWF  6B
0811:  MOVF   59,W
0812:  MOVWF  6A
0813:  BSF    03.5
0814:  CLRF   13
0815:  CLRF   12
0816:  CLRF   11
0817:  CLRF   10
0818:  BCF    0A.3
0819:  BCF    03.5
081A:  BCF    03.6
081B:  CALL   41A
081C:  BSF    0A.3
081D:  BTFSS  03.0
081E:  GOTO   025
....................    { 
....................       s = 1; 
081F:  BSF    03.6
0820:  BSF    69.0
....................       y = -y; 
0821:  MOVF   5E,W
0822:  XORLW  80
0823:  MOVWF  5E
0824:  BCF    03.6
....................    } 
....................  
....................    if (y > 1.0) 
0825:  BSF    03.6
0826:  CLRF   6D
0827:  CLRF   6C
0828:  CLRF   6B
0829:  MOVLW  7F
082A:  MOVWF  6A
082B:  MOVF   60,W
082C:  BSF    03.5
082D:  MOVWF  13
082E:  BCF    03.5
082F:  MOVF   5F,W
0830:  BSF    03.5
0831:  MOVWF  12
0832:  BCF    03.5
0833:  MOVF   5E,W
0834:  BSF    03.5
0835:  MOVWF  11
0836:  BCF    03.5
0837:  MOVF   5D,W
0838:  BSF    03.5
0839:  MOVWF  10
083A:  BCF    0A.3
083B:  BCF    03.5
083C:  BCF    03.6
083D:  CALL   41A
083E:  BSF    0A.3
083F:  BTFSS  03.0
0840:  GOTO   068
....................    { 
....................       y = 1.0/y; 
0841:  BSF    03.5
0842:  BSF    03.6
0843:  CLRF   13
0844:  CLRF   12
0845:  CLRF   11
0846:  MOVLW  7F
0847:  MOVWF  10
0848:  BCF    03.5
0849:  MOVF   60,W
084A:  BSF    03.5
084B:  MOVWF  17
084C:  BCF    03.5
084D:  MOVF   5F,W
084E:  BSF    03.5
084F:  MOVWF  16
0850:  BCF    03.5
0851:  MOVF   5E,W
0852:  BSF    03.5
0853:  MOVWF  15
0854:  BCF    03.5
0855:  MOVF   5D,W
0856:  BSF    03.5
0857:  MOVWF  14
0858:  BCF    0A.3
0859:  BCF    03.5
085A:  BCF    03.6
085B:  CALL   465
085C:  BSF    0A.3
085D:  MOVF   7A,W
085E:  BSF    03.6
085F:  MOVWF  60
0860:  MOVF   79,W
0861:  MOVWF  5F
0862:  MOVF   78,W
0863:  MOVWF  5E
0864:  MOVF   77,W
0865:  MOVWF  5D
....................       flag = 1; 
0866:  BSF    69.1
0867:  BCF    03.6
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
0868:  MOVLW  0A
0869:  BSF    03.5
086A:  BSF    03.6
086B:  MOVWF  13
086C:  MOVLW  89
086D:  MOVWF  12
086E:  MOVLW  34
086F:  MOVWF  11
0870:  MOVLW  7C
0871:  MOVWF  10
0872:  BCF    03.5
0873:  MOVF   60,W
0874:  BSF    03.5
0875:  MOVWF  17
0876:  BCF    03.5
0877:  MOVF   5F,W
0878:  BSF    03.5
0879:  MOVWF  16
087A:  BCF    03.5
087B:  MOVF   5E,W
087C:  BSF    03.5
087D:  MOVWF  15
087E:  BCF    03.5
087F:  MOVF   5D,W
0880:  BSF    03.5
0881:  MOVWF  14
0882:  BCF    0A.3
0883:  BCF    03.5
0884:  BCF    03.6
0885:  CALL   533
0886:  BSF    0A.3
0887:  MOVF   7A,W
0888:  BSF    03.6
0889:  MOVWF  6D
088A:  MOVF   79,W
088B:  MOVWF  6C
088C:  MOVF   78,W
088D:  MOVWF  6B
088E:  MOVF   77,W
088F:  MOVWF  6A
0890:  MOVF   6D,W
0891:  BSF    03.5
0892:  MOVWF  13
0893:  BCF    03.5
0894:  MOVF   6C,W
0895:  BSF    03.5
0896:  MOVWF  12
0897:  BCF    03.5
0898:  MOVF   6B,W
0899:  BSF    03.5
089A:  MOVWF  11
089B:  BCF    03.5
089C:  MOVF   6A,W
089D:  BSF    03.5
089E:  MOVWF  10
089F:  BCF    03.5
08A0:  MOVF   60,W
08A1:  BSF    03.5
08A2:  MOVWF  17
08A3:  BCF    03.5
08A4:  MOVF   5F,W
08A5:  BSF    03.5
08A6:  MOVWF  16
08A7:  BCF    03.5
08A8:  MOVF   5E,W
08A9:  BSF    03.5
08AA:  MOVWF  15
08AB:  BCF    03.5
08AC:  MOVF   5D,W
08AD:  BSF    03.5
08AE:  MOVWF  14
08AF:  BCF    0A.3
08B0:  BCF    03.5
08B1:  BCF    03.6
08B2:  CALL   533
08B3:  BSF    0A.3
08B4:  MOVF   7A,W
08B5:  BSF    03.6
08B6:  MOVWF  6D
08B7:  MOVF   79,W
08B8:  MOVWF  6C
08B9:  MOVF   78,W
08BA:  MOVWF  6B
08BB:  MOVF   77,W
08BC:  MOVWF  6A
08BD:  BCF    03.1
08BE:  BCF    03.6
08BF:  CLRF   2B
08C0:  BTFSC  0B.7
08C1:  BSF    2B.7
08C2:  BCF    0B.7
08C3:  BSF    03.6
08C4:  MOVF   6D,W
08C5:  BSF    03.5
08C6:  MOVWF  27
08C7:  BCF    03.5
08C8:  MOVF   6C,W
08C9:  BSF    03.5
08CA:  MOVWF  26
08CB:  BCF    03.5
08CC:  MOVF   6B,W
08CD:  BSF    03.5
08CE:  MOVWF  25
08CF:  BCF    03.5
08D0:  MOVF   6A,W
08D1:  BSF    03.5
08D2:  MOVWF  24
08D3:  MOVLW  7C
08D4:  MOVWF  2B
08D5:  MOVLW  79
08D6:  MOVWF  2A
08D7:  MOVLW  35
08D8:  MOVWF  29
08D9:  MOVLW  81
08DA:  MOVWF  28
08DB:  BCF    0A.3
08DC:  BCF    03.5
08DD:  BCF    03.6
08DE:  CALL   058
08DF:  BSF    0A.3
08E0:  BTFSC  2B.7
08E1:  BSF    0B.7
08E2:  MOVF   7A,W
08E3:  BSF    03.6
08E4:  MOVWF  64
08E5:  MOVF   79,W
08E6:  MOVWF  63
08E7:  MOVF   78,W
08E8:  MOVWF  62
08E9:  MOVF   77,W
08EA:  MOVWF  61
....................    res = res*y*y + pat[2]; 
08EB:  MOVF   64,W
08EC:  BSF    03.5
08ED:  MOVWF  13
08EE:  BCF    03.5
08EF:  MOVF   63,W
08F0:  BSF    03.5
08F1:  MOVWF  12
08F2:  BCF    03.5
08F3:  MOVF   62,W
08F4:  BSF    03.5
08F5:  MOVWF  11
08F6:  BCF    03.5
08F7:  MOVF   61,W
08F8:  BSF    03.5
08F9:  MOVWF  10
08FA:  BCF    03.5
08FB:  MOVF   60,W
08FC:  BSF    03.5
08FD:  MOVWF  17
08FE:  BCF    03.5
08FF:  MOVF   5F,W
0900:  BSF    03.5
0901:  MOVWF  16
0902:  BCF    03.5
0903:  MOVF   5E,W
0904:  BSF    03.5
0905:  MOVWF  15
0906:  BCF    03.5
0907:  MOVF   5D,W
0908:  BSF    03.5
0909:  MOVWF  14
090A:  BCF    0A.3
090B:  BCF    03.5
090C:  BCF    03.6
090D:  CALL   533
090E:  BSF    0A.3
090F:  MOVF   7A,W
0910:  BSF    03.6
0911:  MOVWF  6D
0912:  MOVF   79,W
0913:  MOVWF  6C
0914:  MOVF   78,W
0915:  MOVWF  6B
0916:  MOVF   77,W
0917:  MOVWF  6A
0918:  MOVF   6D,W
0919:  BSF    03.5
091A:  MOVWF  13
091B:  BCF    03.5
091C:  MOVF   6C,W
091D:  BSF    03.5
091E:  MOVWF  12
091F:  BCF    03.5
0920:  MOVF   6B,W
0921:  BSF    03.5
0922:  MOVWF  11
0923:  BCF    03.5
0924:  MOVF   6A,W
0925:  BSF    03.5
0926:  MOVWF  10
0927:  BCF    03.5
0928:  MOVF   60,W
0929:  BSF    03.5
092A:  MOVWF  17
092B:  BCF    03.5
092C:  MOVF   5F,W
092D:  BSF    03.5
092E:  MOVWF  16
092F:  BCF    03.5
0930:  MOVF   5E,W
0931:  BSF    03.5
0932:  MOVWF  15
0933:  BCF    03.5
0934:  MOVF   5D,W
0935:  BSF    03.5
0936:  MOVWF  14
0937:  BCF    0A.3
0938:  BCF    03.5
0939:  BCF    03.6
093A:  CALL   533
093B:  BSF    0A.3
093C:  MOVF   7A,W
093D:  BSF    03.6
093E:  MOVWF  6D
093F:  MOVF   79,W
0940:  MOVWF  6C
0941:  MOVF   78,W
0942:  MOVWF  6B
0943:  MOVF   77,W
0944:  MOVWF  6A
0945:  BCF    03.1
0946:  BCF    03.6
0947:  CLRF   2B
0948:  BTFSC  0B.7
0949:  BSF    2B.7
094A:  BCF    0B.7
094B:  BSF    03.6
094C:  MOVF   6D,W
094D:  BSF    03.5
094E:  MOVWF  27
094F:  BCF    03.5
0950:  MOVF   6C,W
0951:  BSF    03.5
0952:  MOVWF  26
0953:  BCF    03.5
0954:  MOVF   6B,W
0955:  BSF    03.5
0956:  MOVWF  25
0957:  BCF    03.5
0958:  MOVF   6A,W
0959:  BSF    03.5
095A:  MOVWF  24
095B:  MOVLW  3F
095C:  MOVWF  2B
095D:  MOVLW  02
095E:  MOVWF  2A
095F:  MOVLW  33
0960:  MOVWF  29
0961:  MOVLW  83
0962:  MOVWF  28
0963:  BCF    0A.3
0964:  BCF    03.5
0965:  BCF    03.6
0966:  CALL   058
0967:  BSF    0A.3
0968:  BTFSC  2B.7
0969:  BSF    0B.7
096A:  MOVF   7A,W
096B:  BSF    03.6
096C:  MOVWF  64
096D:  MOVF   79,W
096E:  MOVWF  63
096F:  MOVF   78,W
0970:  MOVWF  62
0971:  MOVF   77,W
0972:  MOVWF  61
....................    res = res*y*y + pat[3]; 
0973:  MOVF   64,W
0974:  BSF    03.5
0975:  MOVWF  13
0976:  BCF    03.5
0977:  MOVF   63,W
0978:  BSF    03.5
0979:  MOVWF  12
097A:  BCF    03.5
097B:  MOVF   62,W
097C:  BSF    03.5
097D:  MOVWF  11
097E:  BCF    03.5
097F:  MOVF   61,W
0980:  BSF    03.5
0981:  MOVWF  10
0982:  BCF    03.5
0983:  MOVF   60,W
0984:  BSF    03.5
0985:  MOVWF  17
0986:  BCF    03.5
0987:  MOVF   5F,W
0988:  BSF    03.5
0989:  MOVWF  16
098A:  BCF    03.5
098B:  MOVF   5E,W
098C:  BSF    03.5
098D:  MOVWF  15
098E:  BCF    03.5
098F:  MOVF   5D,W
0990:  BSF    03.5
0991:  MOVWF  14
0992:  BCF    0A.3
0993:  BCF    03.5
0994:  BCF    03.6
0995:  CALL   533
0996:  BSF    0A.3
0997:  MOVF   7A,W
0998:  BSF    03.6
0999:  MOVWF  6D
099A:  MOVF   79,W
099B:  MOVWF  6C
099C:  MOVF   78,W
099D:  MOVWF  6B
099E:  MOVF   77,W
099F:  MOVWF  6A
09A0:  MOVF   6D,W
09A1:  BSF    03.5
09A2:  MOVWF  13
09A3:  BCF    03.5
09A4:  MOVF   6C,W
09A5:  BSF    03.5
09A6:  MOVWF  12
09A7:  BCF    03.5
09A8:  MOVF   6B,W
09A9:  BSF    03.5
09AA:  MOVWF  11
09AB:  BCF    03.5
09AC:  MOVF   6A,W
09AD:  BSF    03.5
09AE:  MOVWF  10
09AF:  BCF    03.5
09B0:  MOVF   60,W
09B1:  BSF    03.5
09B2:  MOVWF  17
09B3:  BCF    03.5
09B4:  MOVF   5F,W
09B5:  BSF    03.5
09B6:  MOVWF  16
09B7:  BCF    03.5
09B8:  MOVF   5E,W
09B9:  BSF    03.5
09BA:  MOVWF  15
09BB:  BCF    03.5
09BC:  MOVF   5D,W
09BD:  BSF    03.5
09BE:  MOVWF  14
09BF:  BCF    0A.3
09C0:  BCF    03.5
09C1:  BCF    03.6
09C2:  CALL   533
09C3:  BSF    0A.3
09C4:  MOVF   7A,W
09C5:  BSF    03.6
09C6:  MOVWF  6D
09C7:  MOVF   79,W
09C8:  MOVWF  6C
09C9:  MOVF   78,W
09CA:  MOVWF  6B
09CB:  MOVF   77,W
09CC:  MOVWF  6A
09CD:  BCF    03.1
09CE:  BCF    03.6
09CF:  CLRF   2B
09D0:  BTFSC  0B.7
09D1:  BSF    2B.7
09D2:  BCF    0B.7
09D3:  BSF    03.6
09D4:  MOVF   6D,W
09D5:  BSF    03.5
09D6:  MOVWF  27
09D7:  BCF    03.5
09D8:  MOVF   6C,W
09D9:  BSF    03.5
09DA:  MOVWF  26
09DB:  BCF    03.5
09DC:  MOVF   6B,W
09DD:  BSF    03.5
09DE:  MOVWF  25
09DF:  BCF    03.5
09E0:  MOVF   6A,W
09E1:  BSF    03.5
09E2:  MOVWF  24
09E3:  MOVLW  33
09E4:  MOVWF  2B
09E5:  MOVLW  8C
09E6:  MOVWF  2A
09E7:  MOVLW  1E
09E8:  MOVWF  29
09E9:  MOVLW  83
09EA:  MOVWF  28
09EB:  BCF    0A.3
09EC:  BCF    03.5
09ED:  BCF    03.6
09EE:  CALL   058
09EF:  BSF    0A.3
09F0:  BTFSC  2B.7
09F1:  BSF    0B.7
09F2:  MOVF   7A,W
09F3:  BSF    03.6
09F4:  MOVWF  64
09F5:  MOVF   79,W
09F6:  MOVWF  63
09F7:  MOVF   78,W
09F8:  MOVWF  62
09F9:  MOVF   77,W
09FA:  MOVWF  61
....................  
....................    r = qat[0]*y*y + qat[1]; 
09FB:  BSF    03.5
09FC:  CLRF   13
09FD:  CLRF   12
09FE:  CLRF   11
09FF:  MOVLW  7F
0A00:  MOVWF  10
0A01:  BCF    03.5
0A02:  MOVF   60,W
0A03:  BSF    03.5
0A04:  MOVWF  17
0A05:  BCF    03.5
0A06:  MOVF   5F,W
0A07:  BSF    03.5
0A08:  MOVWF  16
0A09:  BCF    03.5
0A0A:  MOVF   5E,W
0A0B:  BSF    03.5
0A0C:  MOVWF  15
0A0D:  BCF    03.5
0A0E:  MOVF   5D,W
0A0F:  BSF    03.5
0A10:  MOVWF  14
0A11:  BCF    0A.3
0A12:  BCF    03.5
0A13:  BCF    03.6
0A14:  CALL   533
0A15:  BSF    0A.3
0A16:  MOVF   7A,W
0A17:  BSF    03.6
0A18:  MOVWF  6D
0A19:  MOVF   79,W
0A1A:  MOVWF  6C
0A1B:  MOVF   78,W
0A1C:  MOVWF  6B
0A1D:  MOVF   77,W
0A1E:  MOVWF  6A
0A1F:  MOVF   6D,W
0A20:  BSF    03.5
0A21:  MOVWF  13
0A22:  BCF    03.5
0A23:  MOVF   6C,W
0A24:  BSF    03.5
0A25:  MOVWF  12
0A26:  BCF    03.5
0A27:  MOVF   6B,W
0A28:  BSF    03.5
0A29:  MOVWF  11
0A2A:  BCF    03.5
0A2B:  MOVF   6A,W
0A2C:  BSF    03.5
0A2D:  MOVWF  10
0A2E:  BCF    03.5
0A2F:  MOVF   60,W
0A30:  BSF    03.5
0A31:  MOVWF  17
0A32:  BCF    03.5
0A33:  MOVF   5F,W
0A34:  BSF    03.5
0A35:  MOVWF  16
0A36:  BCF    03.5
0A37:  MOVF   5E,W
0A38:  BSF    03.5
0A39:  MOVWF  15
0A3A:  BCF    03.5
0A3B:  MOVF   5D,W
0A3C:  BSF    03.5
0A3D:  MOVWF  14
0A3E:  BCF    0A.3
0A3F:  BCF    03.5
0A40:  BCF    03.6
0A41:  CALL   533
0A42:  BSF    0A.3
0A43:  MOVF   7A,W
0A44:  BSF    03.6
0A45:  MOVWF  6D
0A46:  MOVF   79,W
0A47:  MOVWF  6C
0A48:  MOVF   78,W
0A49:  MOVWF  6B
0A4A:  MOVF   77,W
0A4B:  MOVWF  6A
0A4C:  BCF    03.1
0A4D:  BCF    03.6
0A4E:  CLRF   2B
0A4F:  BTFSC  0B.7
0A50:  BSF    2B.7
0A51:  BCF    0B.7
0A52:  BSF    03.6
0A53:  MOVF   6D,W
0A54:  BSF    03.5
0A55:  MOVWF  27
0A56:  BCF    03.5
0A57:  MOVF   6C,W
0A58:  BSF    03.5
0A59:  MOVWF  26
0A5A:  BCF    03.5
0A5B:  MOVF   6B,W
0A5C:  BSF    03.5
0A5D:  MOVWF  25
0A5E:  BCF    03.5
0A5F:  MOVF   6A,W
0A60:  BSF    03.5
0A61:  MOVWF  24
0A62:  MOVLW  1B
0A63:  MOVWF  2B
0A64:  MOVLW  E4
0A65:  MOVWF  2A
0A66:  MOVLW  35
0A67:  MOVWF  29
0A68:  MOVLW  82
0A69:  MOVWF  28
0A6A:  BCF    0A.3
0A6B:  BCF    03.5
0A6C:  BCF    03.6
0A6D:  CALL   058
0A6E:  BSF    0A.3
0A6F:  BTFSC  2B.7
0A70:  BSF    0B.7
0A71:  MOVF   7A,W
0A72:  BSF    03.6
0A73:  MOVWF  68
0A74:  MOVF   79,W
0A75:  MOVWF  67
0A76:  MOVF   78,W
0A77:  MOVWF  66
0A78:  MOVF   77,W
0A79:  MOVWF  65
....................    r = r*y*y + qat[2]; 
0A7A:  MOVF   68,W
0A7B:  BSF    03.5
0A7C:  MOVWF  13
0A7D:  BCF    03.5
0A7E:  MOVF   67,W
0A7F:  BSF    03.5
0A80:  MOVWF  12
0A81:  BCF    03.5
0A82:  MOVF   66,W
0A83:  BSF    03.5
0A84:  MOVWF  11
0A85:  BCF    03.5
0A86:  MOVF   65,W
0A87:  BSF    03.5
0A88:  MOVWF  10
0A89:  BCF    03.5
0A8A:  MOVF   60,W
0A8B:  BSF    03.5
0A8C:  MOVWF  17
0A8D:  BCF    03.5
0A8E:  MOVF   5F,W
0A8F:  BSF    03.5
0A90:  MOVWF  16
0A91:  BCF    03.5
0A92:  MOVF   5E,W
0A93:  BSF    03.5
0A94:  MOVWF  15
0A95:  BCF    03.5
0A96:  MOVF   5D,W
0A97:  BSF    03.5
0A98:  MOVWF  14
0A99:  BCF    0A.3
0A9A:  BCF    03.5
0A9B:  BCF    03.6
0A9C:  CALL   533
0A9D:  BSF    0A.3
0A9E:  MOVF   7A,W
0A9F:  BSF    03.6
0AA0:  MOVWF  6D
0AA1:  MOVF   79,W
0AA2:  MOVWF  6C
0AA3:  MOVF   78,W
0AA4:  MOVWF  6B
0AA5:  MOVF   77,W
0AA6:  MOVWF  6A
0AA7:  MOVF   6D,W
0AA8:  BSF    03.5
0AA9:  MOVWF  13
0AAA:  BCF    03.5
0AAB:  MOVF   6C,W
0AAC:  BSF    03.5
0AAD:  MOVWF  12
0AAE:  BCF    03.5
0AAF:  MOVF   6B,W
0AB0:  BSF    03.5
0AB1:  MOVWF  11
0AB2:  BCF    03.5
0AB3:  MOVF   6A,W
0AB4:  BSF    03.5
0AB5:  MOVWF  10
0AB6:  BCF    03.5
0AB7:  MOVF   60,W
0AB8:  BSF    03.5
0AB9:  MOVWF  17
0ABA:  BCF    03.5
0ABB:  MOVF   5F,W
0ABC:  BSF    03.5
0ABD:  MOVWF  16
0ABE:  BCF    03.5
0ABF:  MOVF   5E,W
0AC0:  BSF    03.5
0AC1:  MOVWF  15
0AC2:  BCF    03.5
0AC3:  MOVF   5D,W
0AC4:  BSF    03.5
0AC5:  MOVWF  14
0AC6:  BCF    0A.3
0AC7:  BCF    03.5
0AC8:  BCF    03.6
0AC9:  CALL   533
0ACA:  BSF    0A.3
0ACB:  MOVF   7A,W
0ACC:  BSF    03.6
0ACD:  MOVWF  6D
0ACE:  MOVF   79,W
0ACF:  MOVWF  6C
0AD0:  MOVF   78,W
0AD1:  MOVWF  6B
0AD2:  MOVF   77,W
0AD3:  MOVWF  6A
0AD4:  BCF    03.1
0AD5:  BCF    03.6
0AD6:  CLRF   2B
0AD7:  BTFSC  0B.7
0AD8:  BSF    2B.7
0AD9:  BCF    0B.7
0ADA:  BSF    03.6
0ADB:  MOVF   6D,W
0ADC:  BSF    03.5
0ADD:  MOVWF  27
0ADE:  BCF    03.5
0ADF:  MOVF   6C,W
0AE0:  BSF    03.5
0AE1:  MOVWF  26
0AE2:  BCF    03.5
0AE3:  MOVF   6B,W
0AE4:  BSF    03.5
0AE5:  MOVWF  25
0AE6:  BCF    03.5
0AE7:  MOVF   6A,W
0AE8:  BSF    03.5
0AE9:  MOVWF  24
0AEA:  MOVLW  A4
0AEB:  MOVWF  2B
0AEC:  MOVLW  DB
0AED:  MOVWF  2A
0AEE:  MOVLW  67
0AEF:  MOVWF  29
0AF0:  MOVLW  83
0AF1:  MOVWF  28
0AF2:  BCF    0A.3
0AF3:  BCF    03.5
0AF4:  BCF    03.6
0AF5:  CALL   058
0AF6:  BSF    0A.3
0AF7:  BTFSC  2B.7
0AF8:  BSF    0B.7
0AF9:  MOVF   7A,W
0AFA:  BSF    03.6
0AFB:  MOVWF  68
0AFC:  MOVF   79,W
0AFD:  MOVWF  67
0AFE:  MOVF   78,W
0AFF:  MOVWF  66
0B00:  MOVF   77,W
0B01:  MOVWF  65
....................    r = r*y*y + qat[3]; 
0B02:  MOVF   68,W
0B03:  BSF    03.5
0B04:  MOVWF  13
0B05:  BCF    03.5
0B06:  MOVF   67,W
0B07:  BSF    03.5
0B08:  MOVWF  12
0B09:  BCF    03.5
0B0A:  MOVF   66,W
0B0B:  BSF    03.5
0B0C:  MOVWF  11
0B0D:  BCF    03.5
0B0E:  MOVF   65,W
0B0F:  BSF    03.5
0B10:  MOVWF  10
0B11:  BCF    03.5
0B12:  MOVF   60,W
0B13:  BSF    03.5
0B14:  MOVWF  17
0B15:  BCF    03.5
0B16:  MOVF   5F,W
0B17:  BSF    03.5
0B18:  MOVWF  16
0B19:  BCF    03.5
0B1A:  MOVF   5E,W
0B1B:  BSF    03.5
0B1C:  MOVWF  15
0B1D:  BCF    03.5
0B1E:  MOVF   5D,W
0B1F:  BSF    03.5
0B20:  MOVWF  14
0B21:  BCF    0A.3
0B22:  BCF    03.5
0B23:  BCF    03.6
0B24:  CALL   533
0B25:  BSF    0A.3
0B26:  MOVF   7A,W
0B27:  BSF    03.6
0B28:  MOVWF  6D
0B29:  MOVF   79,W
0B2A:  MOVWF  6C
0B2B:  MOVF   78,W
0B2C:  MOVWF  6B
0B2D:  MOVF   77,W
0B2E:  MOVWF  6A
0B2F:  MOVF   6D,W
0B30:  BSF    03.5
0B31:  MOVWF  13
0B32:  BCF    03.5
0B33:  MOVF   6C,W
0B34:  BSF    03.5
0B35:  MOVWF  12
0B36:  BCF    03.5
0B37:  MOVF   6B,W
0B38:  BSF    03.5
0B39:  MOVWF  11
0B3A:  BCF    03.5
0B3B:  MOVF   6A,W
0B3C:  BSF    03.5
0B3D:  MOVWF  10
0B3E:  BCF    03.5
0B3F:  MOVF   60,W
0B40:  BSF    03.5
0B41:  MOVWF  17
0B42:  BCF    03.5
0B43:  MOVF   5F,W
0B44:  BSF    03.5
0B45:  MOVWF  16
0B46:  BCF    03.5
0B47:  MOVF   5E,W
0B48:  BSF    03.5
0B49:  MOVWF  15
0B4A:  BCF    03.5
0B4B:  MOVF   5D,W
0B4C:  BSF    03.5
0B4D:  MOVWF  14
0B4E:  BCF    0A.3
0B4F:  BCF    03.5
0B50:  BCF    03.6
0B51:  CALL   533
0B52:  BSF    0A.3
0B53:  MOVF   7A,W
0B54:  BSF    03.6
0B55:  MOVWF  6D
0B56:  MOVF   79,W
0B57:  MOVWF  6C
0B58:  MOVF   78,W
0B59:  MOVWF  6B
0B5A:  MOVF   77,W
0B5B:  MOVWF  6A
0B5C:  BCF    03.1
0B5D:  BCF    03.6
0B5E:  CLRF   2B
0B5F:  BTFSC  0B.7
0B60:  BSF    2B.7
0B61:  BCF    0B.7
0B62:  BSF    03.6
0B63:  MOVF   6D,W
0B64:  BSF    03.5
0B65:  MOVWF  27
0B66:  BCF    03.5
0B67:  MOVF   6C,W
0B68:  BSF    03.5
0B69:  MOVWF  26
0B6A:  BCF    03.5
0B6B:  MOVF   6B,W
0B6C:  BSF    03.5
0B6D:  MOVWF  25
0B6E:  BCF    03.5
0B6F:  MOVF   6A,W
0B70:  BSF    03.5
0B71:  MOVWF  24
0B72:  MOVLW  33
0B73:  MOVWF  2B
0B74:  MOVLW  8C
0B75:  MOVWF  2A
0B76:  MOVLW  1E
0B77:  MOVWF  29
0B78:  MOVLW  83
0B79:  MOVWF  28
0B7A:  BCF    0A.3
0B7B:  BCF    03.5
0B7C:  BCF    03.6
0B7D:  CALL   058
0B7E:  BSF    0A.3
0B7F:  BTFSC  2B.7
0B80:  BSF    0B.7
0B81:  MOVF   7A,W
0B82:  BSF    03.6
0B83:  MOVWF  68
0B84:  MOVF   79,W
0B85:  MOVWF  67
0B86:  MOVF   78,W
0B87:  MOVWF  66
0B88:  MOVF   77,W
0B89:  MOVWF  65
....................  
....................    res = y*res/r; 
0B8A:  MOVF   60,W
0B8B:  BSF    03.5
0B8C:  MOVWF  13
0B8D:  BCF    03.5
0B8E:  MOVF   5F,W
0B8F:  BSF    03.5
0B90:  MOVWF  12
0B91:  BCF    03.5
0B92:  MOVF   5E,W
0B93:  BSF    03.5
0B94:  MOVWF  11
0B95:  BCF    03.5
0B96:  MOVF   5D,W
0B97:  BSF    03.5
0B98:  MOVWF  10
0B99:  BCF    03.5
0B9A:  MOVF   64,W
0B9B:  BSF    03.5
0B9C:  MOVWF  17
0B9D:  BCF    03.5
0B9E:  MOVF   63,W
0B9F:  BSF    03.5
0BA0:  MOVWF  16
0BA1:  BCF    03.5
0BA2:  MOVF   62,W
0BA3:  BSF    03.5
0BA4:  MOVWF  15
0BA5:  BCF    03.5
0BA6:  MOVF   61,W
0BA7:  BSF    03.5
0BA8:  MOVWF  14
0BA9:  BCF    0A.3
0BAA:  BCF    03.5
0BAB:  BCF    03.6
0BAC:  CALL   533
0BAD:  BSF    0A.3
0BAE:  MOVF   7A,W
0BAF:  BSF    03.6
0BB0:  MOVWF  6D
0BB1:  MOVF   79,W
0BB2:  MOVWF  6C
0BB3:  MOVF   78,W
0BB4:  MOVWF  6B
0BB5:  MOVF   77,W
0BB6:  MOVWF  6A
0BB7:  MOVF   6D,W
0BB8:  BSF    03.5
0BB9:  MOVWF  13
0BBA:  BCF    03.5
0BBB:  MOVF   6C,W
0BBC:  BSF    03.5
0BBD:  MOVWF  12
0BBE:  BCF    03.5
0BBF:  MOVF   6B,W
0BC0:  BSF    03.5
0BC1:  MOVWF  11
0BC2:  BCF    03.5
0BC3:  MOVF   6A,W
0BC4:  BSF    03.5
0BC5:  MOVWF  10
0BC6:  BCF    03.5
0BC7:  MOVF   68,W
0BC8:  BSF    03.5
0BC9:  MOVWF  17
0BCA:  BCF    03.5
0BCB:  MOVF   67,W
0BCC:  BSF    03.5
0BCD:  MOVWF  16
0BCE:  BCF    03.5
0BCF:  MOVF   66,W
0BD0:  BSF    03.5
0BD1:  MOVWF  15
0BD2:  BCF    03.5
0BD3:  MOVF   65,W
0BD4:  BSF    03.5
0BD5:  MOVWF  14
0BD6:  BCF    0A.3
0BD7:  BCF    03.5
0BD8:  BCF    03.6
0BD9:  CALL   465
0BDA:  BSF    0A.3
0BDB:  MOVF   7A,W
0BDC:  BSF    03.6
0BDD:  MOVWF  64
0BDE:  MOVF   79,W
0BDF:  MOVWF  63
0BE0:  MOVF   78,W
0BE1:  MOVWF  62
0BE2:  MOVF   77,W
0BE3:  MOVWF  61
....................  
....................  
....................    if (flag)                              // for |x| > 1 
0BE4:  BTFSS  69.1
0BE5:  GOTO   416
....................       res = PI_DIV_BY_TWO - res; 
0BE6:  BSF    03.1
0BE7:  BCF    03.6
0BE8:  CLRF   2B
0BE9:  BTFSC  0B.7
0BEA:  BSF    2B.7
0BEB:  BCF    0B.7
0BEC:  MOVLW  DB
0BED:  BSF    03.5
0BEE:  BSF    03.6
0BEF:  MOVWF  27
0BF0:  MOVLW  0F
0BF1:  MOVWF  26
0BF2:  MOVLW  49
0BF3:  MOVWF  25
0BF4:  MOVLW  7F
0BF5:  MOVWF  24
0BF6:  BCF    03.5
0BF7:  MOVF   64,W
0BF8:  BSF    03.5
0BF9:  MOVWF  2B
0BFA:  BCF    03.5
0BFB:  MOVF   63,W
0BFC:  BSF    03.5
0BFD:  MOVWF  2A
0BFE:  BCF    03.5
0BFF:  MOVF   62,W
0C00:  BSF    03.5
0C01:  MOVWF  29
0C02:  BCF    03.5
0C03:  MOVF   61,W
0C04:  BSF    03.5
0C05:  MOVWF  28
0C06:  BCF    0A.3
0C07:  BCF    03.5
0C08:  BCF    03.6
0C09:  CALL   058
0C0A:  BSF    0A.3
0C0B:  BTFSC  2B.7
0C0C:  BSF    0B.7
0C0D:  MOVF   7A,W
0C0E:  BSF    03.6
0C0F:  MOVWF  64
0C10:  MOVF   79,W
0C11:  MOVWF  63
0C12:  MOVF   78,W
0C13:  MOVWF  62
0C14:  MOVF   77,W
0C15:  MOVWF  61
....................    if (s) 
0C16:  BTFSS  69.0
0C17:  GOTO   41B
....................       res = -res; 
0C18:  MOVF   62,W
0C19:  XORLW  80
0C1A:  MOVWF  62
....................  
....................    return(res); 
0C1B:  MOVF   61,W
0C1C:  MOVWF  77
0C1D:  MOVF   62,W
0C1E:  MOVWF  78
0C1F:  MOVF   63,W
0C20:  MOVWF  79
0C21:  MOVF   64,W
0C22:  MOVWF  7A
0C23:  BCF    03.6
0C24:  RETURN
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
*
05AC:  BSF    03.6
05AD:  BCF    57.0
....................    quad=0; //quadrant 
05AE:  CLRF   58
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
05AF:  MOVF   4E,W
05B0:  MOVWF  6D
05B1:  MOVF   4D,W
05B2:  MOVWF  6C
05B3:  MOVF   4C,W
05B4:  MOVWF  6B
05B5:  MOVF   4B,W
05B6:  MOVWF  6A
05B7:  BSF    03.5
05B8:  CLRF   13
05B9:  CLRF   12
05BA:  CLRF   11
05BB:  CLRF   10
05BC:  BCF    03.5
05BD:  BCF    03.6
05BE:  CALL   41A
05BF:  BTFSC  03.0
05C0:  GOTO   5C3
05C1:  BTFSS  03.2
05C2:  GOTO   5DC
05C3:  BSF    03.6
05C4:  MOVF   52,W
05C5:  MOVWF  6D
05C6:  MOVF   51,W
05C7:  MOVWF  6C
05C8:  MOVF   50,W
05C9:  MOVWF  6B
05CA:  MOVF   4F,W
05CB:  MOVWF  6A
05CC:  BSF    03.5
05CD:  CLRF   13
05CE:  CLRF   12
05CF:  CLRF   11
05D0:  CLRF   10
05D1:  BCF    03.5
05D2:  BCF    03.6
05D3:  CALL   41A
05D4:  BTFSC  03.0
05D5:  GOTO   5D8
05D6:  BTFSS  03.2
05D7:  GOTO   5DA
05D8:  MOVLW  03
05D9:  GOTO   5DB
05DA:  MOVLW  04
05DB:  GOTO   5F2
05DC:  BSF    03.6
05DD:  MOVF   52,W
05DE:  MOVWF  6D
05DF:  MOVF   51,W
05E0:  MOVWF  6C
05E1:  MOVF   50,W
05E2:  MOVWF  6B
05E3:  MOVF   4F,W
05E4:  MOVWF  6A
05E5:  BSF    03.5
05E6:  CLRF   13
05E7:  CLRF   12
05E8:  CLRF   11
05E9:  CLRF   10
05EA:  BCF    03.5
05EB:  BCF    03.6
05EC:  CALL   41A
05ED:  BTFSS  03.0
05EE:  GOTO   5F1
05EF:  MOVLW  02
05F0:  GOTO   5F2
05F1:  MOVLW  01
05F2:  BSF    03.6
05F3:  MOVWF  58
....................    if(y<0.0) 
05F4:  MOVF   4E,W
05F5:  MOVWF  6D
05F6:  MOVF   4D,W
05F7:  MOVWF  6C
05F8:  MOVF   4C,W
05F9:  MOVWF  6B
05FA:  MOVF   4B,W
05FB:  MOVWF  6A
05FC:  BSF    03.5
05FD:  CLRF   13
05FE:  CLRF   12
05FF:  CLRF   11
0600:  CLRF   10
0601:  BCF    03.5
0602:  BCF    03.6
0603:  CALL   41A
0604:  BTFSS  03.0
0605:  GOTO   60C
....................    { 
....................       sign=1; 
0606:  BSF    03.6
0607:  BSF    57.0
....................       y=-y; 
0608:  MOVF   4C,W
0609:  XORLW  80
060A:  MOVWF  4C
060B:  BCF    03.6
....................    } 
....................    if(x<0.0) 
060C:  BSF    03.6
060D:  MOVF   52,W
060E:  MOVWF  6D
060F:  MOVF   51,W
0610:  MOVWF  6C
0611:  MOVF   50,W
0612:  MOVWF  6B
0613:  MOVF   4F,W
0614:  MOVWF  6A
0615:  BSF    03.5
0616:  CLRF   13
0617:  CLRF   12
0618:  CLRF   11
0619:  CLRF   10
061A:  BCF    03.5
061B:  BCF    03.6
061C:  CALL   41A
061D:  BTFSS  03.0
061E:  GOTO   624
....................    { 
....................       x=-x; 
061F:  BSF    03.6
0620:  MOVF   50,W
0621:  XORLW  80
0622:  MOVWF  50
0623:  BCF    03.6
....................    } 
....................    if (x==0.0) 
0624:  BSF    03.6
0625:  MOVF   52,W
0626:  MOVWF  6D
0627:  MOVF   51,W
0628:  MOVWF  6C
0629:  MOVF   50,W
062A:  MOVWF  6B
062B:  MOVF   4F,W
062C:  MOVWF  6A
062D:  BSF    03.5
062E:  CLRF   13
062F:  CLRF   12
0630:  CLRF   11
0631:  CLRF   10
0632:  BCF    03.5
0633:  BCF    03.6
0634:  CALL   41A
0635:  BTFSS  03.2
0636:  GOTO   662
....................    { 
....................       if(y==0.0) 
0637:  BSF    03.6
0638:  MOVF   4E,W
0639:  MOVWF  6D
063A:  MOVF   4D,W
063B:  MOVWF  6C
063C:  MOVF   4C,W
063D:  MOVWF  6B
063E:  MOVF   4B,W
063F:  MOVWF  6A
0640:  BSF    03.5
0641:  CLRF   13
0642:  CLRF   12
0643:  CLRF   11
0644:  CLRF   10
0645:  BCF    03.5
0646:  BCF    03.6
0647:  CALL   41A
0648:  BTFSC  03.2
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
0649:  GOTO   661
....................       else 
....................       { 
....................          if(sign) 
064A:  BSF    03.6
064B:  BTFSS  57.0
064C:  GOTO   657
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
064D:  MOVLW  7F
064E:  MOVWF  77
064F:  MOVLW  C9
0650:  MOVWF  78
0651:  MOVLW  0F
0652:  MOVWF  79
0653:  MOVLW  DB
0654:  MOVWF  7A
0655:  GOTO   73D
....................          } 
0656:  GOTO   660
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
0657:  MOVLW  7F
0658:  MOVWF  77
0659:  MOVLW  49
065A:  MOVWF  78
065B:  MOVLW  0F
065C:  MOVWF  79
065D:  MOVLW  DB
065E:  MOVWF  7A
065F:  GOTO   73D
0660:  BCF    03.6
....................          } 
....................       } 
....................    } 
0661:  GOTO   73C
....................    else 
....................    { 
....................       z=y/x; 
0662:  BSF    03.6
0663:  MOVF   4E,W
0664:  BSF    03.5
0665:  MOVWF  13
0666:  BCF    03.5
0667:  MOVF   4D,W
0668:  BSF    03.5
0669:  MOVWF  12
066A:  BCF    03.5
066B:  MOVF   4C,W
066C:  BSF    03.5
066D:  MOVWF  11
066E:  BCF    03.5
066F:  MOVF   4B,W
0670:  BSF    03.5
0671:  MOVWF  10
0672:  BCF    03.5
0673:  MOVF   52,W
0674:  BSF    03.5
0675:  MOVWF  17
0676:  BCF    03.5
0677:  MOVF   51,W
0678:  BSF    03.5
0679:  MOVWF  16
067A:  BCF    03.5
067B:  MOVF   50,W
067C:  BSF    03.5
067D:  MOVWF  15
067E:  BCF    03.5
067F:  MOVF   4F,W
0680:  BSF    03.5
0681:  MOVWF  14
0682:  BCF    03.5
0683:  BCF    03.6
0684:  CALL   465
0685:  MOVF   7A,W
0686:  BSF    03.6
0687:  MOVWF  56
0688:  MOVF   79,W
0689:  MOVWF  55
068A:  MOVF   78,W
068B:  MOVWF  54
068C:  MOVF   77,W
068D:  MOVWF  53
....................       switch(quad) 
068E:  MOVLW  01
068F:  SUBWF  58,W
0690:  ADDLW  FC
0691:  BTFSC  03.0
0692:  GOTO   73D
0693:  ADDLW  04
0694:  BCF    03.6
0695:  GOTO   73F
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
0696:  BSF    03.6
0697:  MOVF   56,W
0698:  MOVWF  5C
0699:  MOVF   55,W
069A:  MOVWF  5B
069B:  MOVF   54,W
069C:  MOVWF  5A
069D:  MOVF   53,W
069E:  MOVWF  59
069F:  BSF    0A.3
06A0:  BCF    03.6
06A1:  CALL   000
06A2:  BCF    0A.3
06A3:  BSF    03.6
06A4:  GOTO   73D
....................             break; 
06A5:  GOTO   73D
06A6:  BCF    03.6
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
06A7:  BSF    03.6
06A8:  MOVF   56,W
06A9:  MOVWF  5C
06AA:  MOVF   55,W
06AB:  MOVWF  5B
06AC:  MOVF   54,W
06AD:  MOVWF  5A
06AE:  MOVF   53,W
06AF:  MOVWF  59
06B0:  BSF    0A.3
06B1:  BCF    03.6
06B2:  CALL   000
06B3:  BCF    0A.3
06B4:  BSF    03.6
06B5:  CLRF   5A
06B6:  MOVF   04,W
06B7:  MOVWF  59
06B8:  BCF    5A.0
06B9:  BTFSC  03.7
06BA:  BSF    5A.0
06BB:  BSF    03.1
06BC:  BCF    03.6
06BD:  CLRF   2B
06BE:  BTFSC  0B.7
06BF:  BSF    2B.7
06C0:  BCF    0B.7
06C1:  MOVLW  DB
06C2:  BSF    03.5
06C3:  BSF    03.6
06C4:  MOVWF  27
06C5:  MOVLW  0F
06C6:  MOVWF  26
06C7:  MOVLW  49
06C8:  MOVWF  25
06C9:  MOVLW  80
06CA:  MOVWF  24
06CB:  MOVF   7A,W
06CC:  MOVWF  2B
06CD:  MOVF   79,W
06CE:  MOVWF  2A
06CF:  MOVF   78,W
06D0:  MOVWF  29
06D1:  MOVF   77,W
06D2:  MOVWF  28
06D3:  BCF    03.5
06D4:  BCF    03.6
06D5:  CALL   058
06D6:  BTFSC  2B.7
06D7:  BSF    0B.7
06D8:  BSF    03.6
06D9:  MOVF   59,W
06DA:  MOVWF  04
06DB:  BCF    03.7
06DC:  BTFSC  5A.0
06DD:  BSF    03.7
06DE:  GOTO   73D
....................             break; 
06DF:  GOTO   73D
06E0:  BCF    03.6
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
06E1:  BSF    03.6
06E2:  MOVF   56,W
06E3:  MOVWF  5C
06E4:  MOVF   55,W
06E5:  MOVWF  5B
06E6:  MOVF   54,W
06E7:  MOVWF  5A
06E8:  MOVF   53,W
06E9:  MOVWF  59
06EA:  BSF    0A.3
06EB:  BCF    03.6
06EC:  CALL   000
06ED:  BCF    0A.3
06EE:  MOVF   7A,W
06EF:  BSF    03.6
06F0:  MOVWF  5C
06F1:  MOVF   79,W
06F2:  MOVWF  5B
06F3:  MOVF   78,W
06F4:  MOVWF  5A
06F5:  MOVF   77,W
06F6:  MOVWF  59
06F7:  CLRF   5E
06F8:  MOVF   04,W
06F9:  MOVWF  5D
06FA:  BCF    5E.0
06FB:  BTFSC  03.7
06FC:  BSF    5E.0
06FD:  BSF    03.1
06FE:  BCF    03.6
06FF:  CLRF   2B
0700:  BTFSC  0B.7
0701:  BSF    2B.7
0702:  BCF    0B.7
0703:  BSF    03.6
0704:  MOVF   5C,W
0705:  BSF    03.5
0706:  MOVWF  27
0707:  BCF    03.5
0708:  MOVF   5B,W
0709:  BSF    03.5
070A:  MOVWF  26
070B:  BCF    03.5
070C:  MOVF   5A,W
070D:  BSF    03.5
070E:  MOVWF  25
070F:  BCF    03.5
0710:  MOVF   59,W
0711:  BSF    03.5
0712:  MOVWF  24
0713:  MOVLW  DB
0714:  MOVWF  2B
0715:  MOVLW  0F
0716:  MOVWF  2A
0717:  MOVLW  49
0718:  MOVWF  29
0719:  MOVLW  80
071A:  MOVWF  28
071B:  BCF    03.5
071C:  BCF    03.6
071D:  CALL   058
071E:  BTFSC  2B.7
071F:  BSF    0B.7
0720:  BSF    03.6
0721:  MOVF   5D,W
0722:  MOVWF  04
0723:  BCF    03.7
0724:  BTFSC  5E.0
0725:  BSF    03.7
0726:  GOTO   73D
....................             break; 
0727:  GOTO   73D
0728:  BCF    03.6
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
0729:  BSF    03.6
072A:  MOVF   56,W
072B:  MOVWF  5C
072C:  MOVF   55,W
072D:  MOVWF  5B
072E:  MOVF   54,W
072F:  MOVWF  5A
0730:  MOVF   53,W
0731:  MOVWF  59
0732:  BSF    0A.3
0733:  BCF    03.6
0734:  CALL   000
0735:  BCF    0A.3
0736:  MOVLW  80
0737:  XORWF  78,F
0738:  BSF    03.6
0739:  GOTO   73D
....................             break; 
073A:  GOTO   73D
073B:  BCF    03.6
073C:  BSF    03.6
....................          } 
....................       } 
....................    } 
073D:  BCF    03.6
073E:  RETURN
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "ds1307.h" 
.................... BYTE bin2bcd(BYTE binary_value); 
.................... BYTE bcd2bin(BYTE bcd_value); 
....................  
.................... void ds1307_init(void) 
.................... { 
.................... BYTE initsec = 0; 
.................... BYTE initmin=0; 
.................... BYTE inithr=0; 
.................... BYTE initdow=0; 
.................... BYTE initday=0; 
.................... BYTE initmth=0; 
.................... BYTE inityear=0; 
.................... i2c_start(); 
.................... i2c_write(0xD0);      // WR to RTC 
.................... i2c_write(0x00);      // REG 0 
.................... i2c_start(); 
.................... i2c_write(0xD1);      // RD from RTC 
.................... initsec  = bcd2bin(i2c_read() & 0x7f); 
.................... initmin  = bcd2bin(i2c_read() & 0x7f); 
.................... inithr   = bcd2bin(i2c_read() & 0x3f); 
.................... initdow  = bcd2bin(i2c_read() & 0x7f);   // REG 3 
.................... initday  = bcd2bin(i2c_read() & 0x3f);   // REG 4 
.................... initmth  = bcd2bin(i2c_read() & 0x1f);   // REG 5 
.................... inityear = bcd2bin(i2c_read(0));         // REG 6 
.................... i2c_stop(); 
.................... delay_us(3); 
....................  
.................... i2c_start(); 
.................... i2c_write(0xD0);      // WR to RTC 
.................... i2c_write(0x00);      // REG 0 
.................... i2c_write(bin2bcd(initsec));      // Start oscillator with current seconds value 
.................... i2c_write(bin2bcd(initmin));      // REG 1 
.................... i2c_write(bin2bcd(inithr));       // REG 2 
.................... i2c_write(bin2bcd(initdow));      // REG 3 
.................... i2c_write(bin2bcd(initday));      // REG 4 
.................... i2c_write(bin2bcd(initmth));      // REG 5 
.................... i2c_write(bin2bcd(inityear));     // REG 6 
.................... i2c_start(); 
.................... i2c_write(0xD0);      // WR to RTC 
.................... i2c_write(0x07);      // Control Register 
.................... i2c_write(0x90);      //  squarewave output pin 1Hz 
.................... i2c_stop(); 
.................... } 
....................  
.................... void ds1307_set_date_time(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min, BYTE sec) 
.................... { 
.................... sec &= 0x7F; 
.................... hr &= 0x3F; 
....................  
.................... i2c_start(); 
.................... i2c_write(0xD0);              // I2C write address 
.................... i2c_write(0x00);              // Start at REG 0  Seconds 
.................... i2c_write(bin2bcd(sec));      // REG 0 
.................... i2c_write(bin2bcd(min));      // REG 1 
.................... i2c_write(bin2bcd(hr));       // REG 2 
.................... i2c_write(bin2bcd(dow));      // REG 3 
.................... i2c_write(bin2bcd(day));      // REG 4 
.................... i2c_write(bin2bcd(mth));      // REG 5 
.................... i2c_write(bin2bcd(year));     // REG 6 
.................... i2c_write(0x90);              // REG 7  1Hz squarewave output pin 
.................... i2c_stop(); 
.................... } 
....................  
.................... void ds1307_get_date(BYTE &day, BYTE &mth, BYTE &year, BYTE &dow) 
.................... { 
.................... i2c_start(); 
.................... i2c_write(0xD0); 
.................... i2c_write(0x03);              // Start at REG 3  Day of week 
.................... i2c_start(); 
.................... i2c_write(0xD1); 
.................... dow  = bcd2bin(i2c_read() & 0x7f);   // REG 3 
.................... day  = bcd2bin(i2c_read() & 0x3f);   // REG 4 
.................... mth  = bcd2bin(i2c_read() & 0x1f);   // REG 5 
.................... year = bcd2bin(i2c_read(0));         // REG 6 
.................... i2c_stop(); 
.................... } 
....................  
.................... void ds1307_get_time(BYTE &hr, BYTE &min, BYTE &sec) 
.................... { 
.................... i2c_start(); 
.................... i2c_write(0xD0); 
.................... i2c_write(0x00);                     // Start at REG 0  Seconds 
.................... i2c_start(); 
.................... i2c_write(0xD1); 
.................... sec = bcd2bin(i2c_read() & 0x7f); 
.................... min = bcd2bin(i2c_read() & 0x7f); 
.................... hr  = bcd2bin(i2c_read(0) & 0x3f); 
.................... i2c_stop(); 
.................... } 
....................  
.................... BYTE bin2bcd(BYTE binary_value) 
.................... { 
.................... BYTE temp; 
.................... BYTE retval; 
....................  
.................... temp = binary_value; 
.................... retval = 0; 
....................  
.................... while(1) 
.................... { 
.................... // Get the tens digit by doing multiple subtraction 
.................... // of 10 from the binary value. 
.................... if(temp >= 10) 
.................... { 
.................... temp -= 10; 
.................... retval += 0x10; 
.................... } 
.................... else // Get the ones digit by adding the remainder. 
.................... { 
.................... retval += temp; 
.................... break; 
.................... } 
.................... } 
....................  
.................... return(retval); 
.................... } 
....................  
.................... // Input range  00 to 99. 
.................... BYTE bcd2bin(BYTE bcd_value) 
.................... { 
.................... BYTE temp; 
....................  
.................... temp = bcd_value; 
.................... // Shifting upper digit right by 1 is same as multiplying by 8. 
.................... temp >>= 1; 
.................... // Isolate the bits for the upper digit. 
.................... temp &= 0x78; 
....................  
.................... // Now return: (Tens * 8) + (Tens * 2) + Ones 
....................  
.................... return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
.................... } 
....................  
.................... #include "Kalman.h" 
.................... #ifndef _Kalman_h 
.................... #define _Kalman_h 
....................  
....................     float Q_angle  =  0.0004; //0.001    //0.005 
....................     float Q_gyro   =  0.0002;  //0.003  //0.0003 
....................     float R_angle  =  0.002;  //0.03     //0.008 
....................  
....................     float x_bias = 0; 
....................     float x_angle; 
....................     float P_00 = 0, P_01 = 0, P_10 = 0, P_11 = 0; 
....................     float  y, S; 
....................     float K_0, K_1; 
....................  
....................   float kalmanCalculate(float newAngle, float newRate, int16 looptime) 
....................   { 
....................     float dt = (float)(looptime)/1000; 
....................     x_angle += dt * (newRate - x_bias); 
....................  
.................... //!    P_00 +=  - dt * (P_10 + P_01) + Q_angle * dt; 
....................     P_00 += dt * (dt*P_11 - P_01 - P_10 + Q_angle); 
.................... //!    P_01 +=  - dt * P_11; 
....................     P_01 -= dt * P_11;     
.................... //!    P_10 +=  - dt * P_11; 
....................     P_10 -= dt * P_11; 
.................... //!    P_11 +=  + Q_gyro * dt; 
....................     P_11 += Q_gyro * dt; 
....................  
....................     S = P_00 + R_angle; 
....................      
....................     K_0 = P_00 / S; 
....................     K_1 = P_10 / S; 
....................      
....................     y = newAngle - x_angle; 
....................      
....................     x_angle +=  K_0 * y; 
....................     x_bias  +=  K_1 * y; 
....................  
....................     P_00 -= K_0 * P_00; 
....................     P_01 -= K_0 * P_01; 
....................     P_10 -= K_1 * P_00; 
....................     P_11 -= K_1 * P_01; 
....................      
....................     return x_angle; 
....................   } 
....................  
.................... #endif 
....................  
.................... //!#use ADC=8 
.................... //modified at 11:12 12/14/2018 
.................... #FUSES NOWDT, HS, PUT, NOPROTECT, 
.................... #use DELAY(crystal =22118400) 
*
0747:  MOVLW  44
0748:  MOVWF  04
0749:  BSF    03.7
074A:  MOVF   00,W
074B:  BTFSC  03.2
074C:  GOTO   75B
074D:  MOVLW  07
074E:  MOVWF  78
074F:  CLRF   77
0750:  DECFSZ 77,F
0751:  GOTO   750
0752:  DECFSZ 78,F
0753:  GOTO   74F
0754:  MOVLW  2A
0755:  MOVWF  77
0756:  DECFSZ 77,F
0757:  GOTO   756
0758:  GOTO   759
0759:  DECFSZ 00,F
075A:  GOTO   74D
075B:  BCF    0A.3
075C:  BSF    0A.4
075D:  GOTO   1D7 (RETURN)
.................... #use i2c(Master,Fast,sda=PIN_C4,scl=PIN_C3) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #USE TIMER(TIMER=0,TICK=1ms,BITS=8,NOISR) 
*
0D78:  BTFSS  0B.2
0D79:  GOTO   57D
0D7A:  INCF   61,F
0D7B:  BCF    0B.2
0D7C:  GOTO   582
0D7D:  MOVF   01,W
0D7E:  BTFSS  0B.2
0D7F:  GOTO   583
0D80:  INCF   61,F
0D81:  BCF    0B.2
0D82:  MOVF   01,W
0D83:  MOVWF  77
0D84:  MOVF   61,W
0D85:  MOVWF  78
0D86:  RRF    78,F
0D87:  RRF    77,F
0D88:  RRF    78,F
0D89:  RRF    77,F
0D8A:  RRF    78,F
0D8B:  RRF    77,F
0D8C:  RRF    78,F
0D8D:  RRF    77,F
0D8E:  RETURN
....................    //#priority rda, TIMER0; 
....................  
.................... volatile INT getdata=0; 
.................... unsigned INT16 kp=25, ki=0, kd=50; 
.................... double iterm; 
.................... DOUBLE originalSetpoint = 176.3; 
.................... double setpoint= originalSetpoint; 
.................... double movingAngleOffset = 0.3; 
.................... double inputt, output; 
.................... double lastinput  ; 
.................... INT dir=1; 
.................... INT predir=1; 
.................... double dumemay=1000; 
....................    SIGNED int16 accX, accY, accZ; 
....................    SIGNED int16 gyroX, gyroY, gyroZ; 
....................    DOUBLE accXangle; 
....................    DOUBLE gyroXangle ; 
....................    DOUBLE compfilterAngleX; 
....................    UNSIGNED int16 timer; 
....................    INT16 count = 0; 
....................    INT8 rfinput = 0; 
....................    DOUBLE countt = 0; 
....................    INT co = 1; 
....................    DOUBLE offsetGyro; 
....................   INT RX_Command_Ready = 0;  
....................   INT receivemarker = 0; 
....................    int16 testtimer=0; 
.................... #define RX_SIZE 40          
.................... char RxBuffer[RX_SIZE];     
.................... int Index = 0;    
.................... char smrcv; 
....................    CHAR cc; 
....................       INT senddata = 0; 
....................     
.................... #define RAD_TO_DEG 180/PI 
.................... #define Slave_add 0x68 
....................  
....................  
.................... #INT_rb  
.................... void rb_isr(VOID)  
.................... { 
....................    rfinput = input_change_b ()&0x0F; 
*
01A2:  MOVF   06,W
01A3:  MOVWF  77
01A4:  BSF    03.5
01A5:  MOVF   5E,W
01A6:  XORWF  77,W
01A7:  MOVWF  78
01A8:  MOVF   77,W
01A9:  MOVWF  5E
01AA:  MOVF   78,W
01AB:  ANDLW  0F
01AC:  MOVWF  4C
....................    IF (rfinput > 2) setpoint += 0.05; 
01AD:  MOVF   4C,W
01AE:  SUBLW  02
01AF:  BTFSC  03.0
01B0:  GOTO   1D0
01B1:  BCF    03.1
01B2:  MOVF   74,W
01B3:  BSF    03.6
01B4:  MOVWF  27
01B5:  MOVF   73,W
01B6:  MOVWF  26
01B7:  MOVF   72,W
01B8:  MOVWF  25
01B9:  MOVF   71,W
01BA:  MOVWF  24
01BB:  MOVLW  CD
01BC:  MOVWF  2B
01BD:  MOVLW  CC
01BE:  MOVWF  2A
01BF:  MOVLW  4C
01C0:  MOVWF  29
01C1:  MOVLW  7A
01C2:  MOVWF  28
01C3:  BCF    03.5
01C4:  BCF    03.6
01C5:  CALL   058
01C6:  MOVF   7A,W
01C7:  MOVWF  74
01C8:  MOVF   79,W
01C9:  MOVWF  73
01CA:  MOVF   78,W
01CB:  MOVWF  72
01CC:  MOVF   77,W
01CD:  MOVWF  71
01CE:  GOTO   1EF
01CF:  BSF    03.5
....................    else IF (rfinput == 1) setpoint -= 0.05; 
01D0:  DECFSZ 4C,W
01D1:  GOTO   1F0
01D2:  BSF    03.1
01D3:  MOVF   74,W
01D4:  BSF    03.6
01D5:  MOVWF  27
01D6:  MOVF   73,W
01D7:  MOVWF  26
01D8:  MOVF   72,W
01D9:  MOVWF  25
01DA:  MOVF   71,W
01DB:  MOVWF  24
01DC:  MOVLW  CD
01DD:  MOVWF  2B
01DE:  MOVLW  CC
01DF:  MOVWF  2A
01E0:  MOVLW  4C
01E1:  MOVWF  29
01E2:  MOVLW  7A
01E3:  MOVWF  28
01E4:  BCF    03.5
01E5:  BCF    03.6
01E6:  CALL   058
01E7:  MOVF   7A,W
01E8:  MOVWF  74
01E9:  MOVF   79,W
01EA:  MOVWF  73
01EB:  MOVF   78,W
01EC:  MOVWF  72
01ED:  MOVF   77,W
01EE:  MOVWF  71
01EF:  BSF    03.5
.................... } 
....................  
01F0:  BCF    03.5
01F1:  BCF    0B.0
01F2:  BCF    0A.3
01F3:  BCF    0A.4
01F4:  GOTO   031
.................... #INT_RDA            /*Ng?t khi nh?n d? li?u*/ 
.................... void truongdeptrai() 
.................... { 
....................     
....................    receivemarker = 1; 
01F5:  MOVLW  01
01F6:  BSF    03.5
01F7:  MOVWF  57
....................    CHAR temp; 
....................    temp = getc (); 
01F8:  BCF    03.5
01F9:  BTFSS  0C.5
01FA:  GOTO   1F9
01FB:  MOVF   1A,W
01FC:  BSF    03.5
01FD:  BSF    03.6
01FE:  MOVWF  24
....................  
....................    IF (temp == '#') 
01FF:  MOVF   24,W
0200:  SUBLW  23
0201:  BTFSS  03.2
0202:  GOTO   212
....................    { 
....................       // ! printf ("\n % f ", (FLOAT) get_ticks ()); 
....................       Index = 0; 
0203:  BCF    03.6
0204:  CLRF   5A
....................       RxBuffer[Index] = temp; 
0205:  MOVLW  10
0206:  ADDWF  5A,W
0207:  MOVWF  04
0208:  BSF    03.7
0209:  BSF    03.6
020A:  MOVF   24,W
020B:  MOVWF  00
....................       Index++; 
020C:  BCF    03.6
020D:  INCF   5A,F
....................       smrcv = 1; 
020E:  MOVLW  01
020F:  MOVWF  5B
....................       RETURN; 
0210:  GOTO   236
0211:  BSF    03.6
....................    } 
....................  
....................    IF (temp == '@') 
0212:  MOVF   24,W
0213:  SUBLW  40
0214:  BTFSS  03.2
0215:  GOTO   226
....................    { 
....................       // ! printf ("\n % f .", (FLOAT) get_ticks ()); 
....................       RxBuffer[Index] = temp; 
0216:  MOVLW  10
0217:  BCF    03.6
0218:  ADDWF  5A,W
0219:  MOVWF  04
021A:  BSF    03.7
021B:  BSF    03.6
021C:  MOVF   24,W
021D:  MOVWF  00
....................  
....................       IF (smrcv == 1) 
021E:  BCF    03.6
021F:  DECFSZ 5B,W
0220:  GOTO   224
....................       { 
....................          RX_Command_Ready = 1;  
0221:  MOVLW  01
0222:  MOVWF  56
....................          smrcv = 0; 
0223:  CLRF   5B
....................       } 
....................  
....................       RETURN; 
0224:  GOTO   236
0225:  BSF    03.6
....................    } 
....................  
....................    RxBuffer[Index] = temp; 
0226:  MOVLW  10
0227:  BCF    03.6
0228:  ADDWF  5A,W
0229:  MOVWF  04
022A:  BSF    03.7
022B:  BSF    03.6
022C:  MOVF   24,W
022D:  MOVWF  00
....................  
....................    IF (Index >= (RX_SIZE - 1)) 
022E:  BCF    03.6
022F:  MOVF   5A,W
0230:  SUBLW  26
0231:  BTFSC  03.0
0232:  GOTO   235
....................    Index = 0; 
0233:  CLRF   5A
0234:  GOTO   236
....................  
....................    ELSE 
....................    Index++; 
0235:  INCF   5A,F
0236:  BCF    03.5
0237:  BCF    0C.5
0238:  BCF    0A.3
0239:  BCF    0A.4
023A:  GOTO   031
.................... } 
....................  
.................... //!#INT_TIMER0 
.................... //!void ngat_timer0() 
.................... //!{ 
.................... //!   printf ("\n %f ", (FLOAT) get_ticks ()); 
.................... //!   getdata = 1; 
.................... //!   accX = Mpu6050_GetData (MPU6050_RA_ACCEL_XOUT_H) ; 
.................... //!   accY = Mpu6050_GetData (MPU6050_RA_ACCEL_YOUT_H) ; 
.................... //!   accZ = Mpu6050_GetData (MPU6050_RA_ACCEL_ZOUT_H) ; 
.................... //!   gyroX = Mpu6050_GetData (MPU6050_RA_GYRO_XOUT_H) ; 
.................... //!   gyroY = Mpu6050_GetData (MPU6050_RA_GYRO_YOUT_H) ; 
.................... //!   gyroZ = Mpu6050_GetData (MPU6050_RA_GYRO_ZOUT_H) ; 
.................... //!   accXangle = (atan2 (accY, accZ) + PI) * RAD_TO_DEG; 
.................... //!   DOUBLE gyroXrate = (double) (gyroX + offsetGyro) / 131.0;//313.4 / 303.5 / 
.................... //!    
.................... //!   dumemay += gyroX; 
.................... //!   count++; 
.................... //!   gyroXangle += gyroXrate * 10 / 1000; // ( (DOUBLE) (get_ticks () - timer) / 1000) , 10ms 
.................... //!    
.................... //!   //kalAngleX = kalmanCalculate (accXangle, gyroXrate, 10); 
.................... //!   compfilterAngleX = 0.02 * accXangle + 0.98 * gyroXangle; 
.................... //!    
.................... //!   inputt = compfilterAngleX; 
.................... //!   // ! printf ("\n % f .", (FLOAT) get_ticks ()); 
.................... //!   set_timer0 (255 - 216) ; 
.................... //!} 
....................  
.................... double pid(DOUBLE inputtt); 
.................... unsigned INT move(double speed, int minabsspeed); 
.................... //DOUBLE compfilter(double inacc, double ingyro); 
....................  
.................... void main() 
*
1000:  MOVF   03,W
1001:  ANDLW  1F
1002:  MOVWF  03
1003:  MOVLW  FF
1004:  MOVWF  2C
1005:  MOVLW  17
1006:  MOVWF  30
1007:  MOVLW  B7
1008:  MOVWF  2F
1009:  MOVLW  51
100A:  MOVWF  2E
100B:  MOVLW  73
100C:  MOVWF  2D
100D:  MOVLW  17
100E:  MOVWF  34
100F:  MOVLW  B7
1010:  MOVWF  33
1011:  MOVLW  51
1012:  MOVWF  32
1013:  MOVLW  72
1014:  MOVWF  31
1015:  MOVLW  6F
1016:  MOVWF  38
1017:  MOVLW  12
1018:  MOVWF  37
1019:  MOVLW  03
101A:  MOVWF  36
101B:  MOVLW  76
101C:  MOVWF  35
101D:  CLRF   3C
101E:  CLRF   3B
101F:  CLRF   3A
1020:  CLRF   39
1021:  CLRF   44
1022:  CLRF   43
1023:  CLRF   42
1024:  CLRF   41
1025:  CLRF   48
1026:  CLRF   47
1027:  CLRF   46
1028:  CLRF   45
1029:  CLRF   4C
102A:  CLRF   4B
102B:  CLRF   4A
102C:  CLRF   49
102D:  CLRF   50
102E:  CLRF   4F
102F:  CLRF   4E
1030:  CLRF   4D
1031:  BSF    03.5
1032:  BSF    03.6
1033:  BCF    07.3
1034:  MOVLW  02
1035:  BCF    03.6
1036:  MOVWF  19
1037:  MOVLW  A2
1038:  MOVWF  18
1039:  MOVLW  90
103A:  BCF    03.5
103B:  MOVWF  18
103C:  CLRF   61
103D:  BSF    03.5
103E:  MOVF   01,W
103F:  ANDLW  C0
1040:  IORLW  07
1041:  MOVWF  01
1042:  BCF    03.5
1043:  CLRF   01
1044:  BCF    0B.2
1045:  CLRF   62
1046:  CLRF   64
1047:  MOVLW  19
1048:  MOVWF  63
1049:  CLRF   66
104A:  CLRF   65
104B:  CLRF   68
104C:  MOVLW  32
104D:  MOVWF  67
104E:  MOVLW  CD
104F:  MOVWF  70
1050:  MOVLW  4C
1051:  MOVWF  6F
1052:  MOVLW  30
1053:  MOVWF  6E
1054:  MOVLW  86
1055:  MOVWF  6D
1056:  MOVF   70,W
1057:  MOVWF  74
1058:  MOVF   6F,W
1059:  MOVWF  73
105A:  MOVF   6E,W
105B:  MOVWF  72
105C:  MOVF   6D,W
105D:  MOVWF  71
105E:  MOVLW  9A
105F:  MOVWF  7E
1060:  MOVLW  99
1061:  MOVWF  7D
1062:  MOVLW  19
1063:  MOVWF  7C
1064:  MOVLW  7D
1065:  MOVWF  7B
1066:  MOVLW  01
1067:  MOVWF  75
1068:  MOVWF  76
1069:  BSF    03.5
106A:  CLRF   2F
106B:  CLRF   2E
106C:  MOVLW  7A
106D:  MOVWF  2D
106E:  MOVLW  88
106F:  MOVWF  2C
1070:  CLRF   4B
1071:  CLRF   4A
1072:  CLRF   4C
1073:  CLRF   50
1074:  CLRF   4F
1075:  CLRF   4E
1076:  CLRF   4D
1077:  MOVLW  01
1078:  MOVWF  51
1079:  CLRF   56
107A:  CLRF   57
107B:  CLRF   59
107C:  CLRF   58
107D:  CLRF   5A
107E:  CLRF   5D
107F:  CLRF   5E
1080:  BSF    03.6
1081:  MOVF   09,W
1082:  ANDLW  C0
1083:  MOVWF  09
1084:  BCF    03.6
1085:  BCF    1F.4
1086:  BCF    1F.5
1087:  MOVLW  00
1088:  BSF    03.6
1089:  MOVWF  08
108A:  BCF    03.5
108B:  CLRF   07
108C:  CLRF   08
108D:  CLRF   09
108E:  BCF    03.7
.................... { 
....................     
....................     
....................    Mpu6050_Init (); 
108F:  BCF    0A.4
1090:  BCF    03.6
1091:  GOTO   2EA
1092:  BSF    0A.4
....................    INT firststate = 1; 
1093:  MOVLW  01
1094:  BSF    03.6
1095:  MOVWF  38
....................    set_tris_b (PIN_B5); output_low (PIN_B5); 
1096:  MOVLW  35
1097:  BSF    03.5
1098:  BCF    03.6
1099:  MOVWF  06
109A:  BCF    06.5
109B:  BCF    03.5
109C:  BCF    06.5
....................    port_b_pullups (TRUE); 
109D:  MOVLW  01
109E:  BSF    03.5
109F:  MOVWF  15
10A0:  BCF    01.7
....................    input_change_b (); // Init Change_B state 
10A1:  BCF    03.5
10A2:  MOVF   06,W
10A3:  MOVWF  77
10A4:  BSF    03.5
10A5:  MOVF   5E,W
10A6:  XORWF  77,W
10A7:  MOVWF  78
10A8:  MOVF   77,W
10A9:  MOVWF  5E
....................    clear_interrupt (INT_RB); 
10AA:  BCF    03.5
10AB:  BCF    0B.0
....................    // ! enable_interrupts (INT_RB); 
....................    // ! enable_interrupts (INT_TIMER0); 
....................    enable_interrupts (INT_RDA); 
10AC:  BSF    03.5
10AD:  BSF    0C.5
....................    enable_interrupts (GlOBAL); 
10AE:  MOVLW  C0
10AF:  BCF    03.5
10B0:  IORWF  0B,F
....................     
....................    setup_timer_2 (T2_DIV_BY_1, 250, 1) ; 
10B1:  MOVLW  00
10B2:  MOVWF  78
10B3:  IORLW  04
10B4:  MOVWF  12
10B5:  MOVLW  FA
10B6:  BSF    03.5
10B7:  MOVWF  12
....................    setup_ccp2 (CCP_PWM); 
10B8:  BCF    03.5
10B9:  BCF    2C.1
10BA:  MOVF   2C,W
10BB:  BSF    03.5
10BC:  MOVWF  07
10BD:  BCF    03.5
10BE:  BCF    07.1
10BF:  MOVLW  0C
10C0:  MOVWF  1D
....................    setup_ccp1 (CCP_PWM); 
10C1:  BCF    2C.2
10C2:  MOVF   2C,W
10C3:  BSF    03.5
10C4:  MOVWF  07
10C5:  BCF    03.5
10C6:  BCF    07.2
10C7:  MOVLW  0C
10C8:  MOVWF  17
10C9:  BSF    03.5
10CA:  CLRF   1B
10CB:  CLRF   1C
10CC:  MOVLW  01
10CD:  MOVWF  1D
....................     
.................... //!   setup_timer_0 (T0_INTERNAL|T0_DIV_128); 
.................... //!   set_timer0 (255 - 216) ; 
....................     
....................    INT8 x; 
....................     
....................    accY = Mpu6050_GetData (MPU6050_RA_ACCEL_YOUT_H) ; 
10CE:  MOVLW  3D
10CF:  BCF    03.5
10D0:  BSF    03.6
10D1:  MOVWF  43
10D2:  BCF    0A.4
10D3:  BCF    03.6
10D4:  CALL   377
10D5:  BSF    0A.4
10D6:  MOVF   79,W
10D7:  BSF    03.5
10D8:  MOVWF  33
10D9:  MOVF   78,W
10DA:  MOVWF  32
....................    accZ = Mpu6050_GetData (MPU6050_RA_ACCEL_ZOUT_H) ; 
10DB:  MOVLW  3F
10DC:  BCF    03.5
10DD:  BSF    03.6
10DE:  MOVWF  43
10DF:  BCF    0A.4
10E0:  BCF    03.6
10E1:  CALL   377
10E2:  BSF    0A.4
10E3:  MOVF   79,W
10E4:  BSF    03.5
10E5:  MOVWF  35
10E6:  MOVF   78,W
10E7:  MOVWF  34
....................    accXangle = (atan2 (accY, accZ) + PI) * RAD_TO_DEG; 
10E8:  MOVF   33,W
10E9:  BCF    03.5
10EA:  BSF    03.6
10EB:  MOVWF  48
10EC:  BSF    03.5
10ED:  BCF    03.6
10EE:  MOVF   32,W
10EF:  BCF    03.5
10F0:  BSF    03.6
10F1:  MOVWF  47
10F2:  BCF    0A.4
10F3:  BCF    03.6
10F4:  CALL   3F3
10F5:  BSF    0A.4
10F6:  MOVF   7A,W
10F7:  BSF    03.6
10F8:  MOVWF  46
10F9:  MOVF   79,W
10FA:  MOVWF  45
10FB:  MOVF   78,W
10FC:  MOVWF  44
10FD:  MOVF   77,W
10FE:  MOVWF  43
10FF:  BSF    03.5
1100:  BCF    03.6
1101:  MOVF   35,W
1102:  BCF    03.5
1103:  BSF    03.6
1104:  MOVWF  48
1105:  BSF    03.5
1106:  BCF    03.6
1107:  MOVF   34,W
1108:  BCF    03.5
1109:  BSF    03.6
110A:  MOVWF  47
110B:  BCF    0A.4
110C:  BCF    03.6
110D:  CALL   3F3
110E:  BSF    0A.4
110F:  MOVF   7A,W
1110:  BSF    03.6
1111:  MOVWF  4A
1112:  MOVF   79,W
1113:  MOVWF  49
1114:  MOVF   78,W
1115:  MOVWF  48
1116:  MOVF   77,W
1117:  MOVWF  47
1118:  MOVF   46,W
1119:  MOVWF  4E
111A:  MOVF   45,W
111B:  MOVWF  4D
111C:  MOVF   44,W
111D:  MOVWF  4C
111E:  MOVF   43,W
111F:  MOVWF  4B
1120:  MOVF   4A,W
1121:  MOVWF  52
1122:  MOVF   49,W
1123:  MOVWF  51
1124:  MOVF   48,W
1125:  MOVWF  50
1126:  MOVF   47,W
1127:  MOVWF  4F
1128:  BCF    0A.4
1129:  BCF    03.6
112A:  CALL   5AC
112B:  BSF    0A.4
112C:  MOVF   7A,W
112D:  BSF    03.6
112E:  MOVWF  46
112F:  MOVF   79,W
1130:  MOVWF  45
1131:  MOVF   78,W
1132:  MOVWF  44
1133:  MOVF   77,W
1134:  MOVWF  43
1135:  CLRF   48
1136:  MOVF   04,W
1137:  MOVWF  47
1138:  BCF    48.0
1139:  BTFSC  03.7
113A:  BSF    48.0
113B:  BCF    03.1
113C:  BCF    03.6
113D:  CLRF   2B
113E:  BTFSC  0B.7
113F:  BSF    2B.7
1140:  BCF    0B.7
1141:  BSF    03.6
1142:  MOVF   46,W
1143:  BSF    03.5
1144:  MOVWF  27
1145:  BCF    03.5
1146:  MOVF   45,W
1147:  BSF    03.5
1148:  MOVWF  26
1149:  BCF    03.5
114A:  MOVF   44,W
114B:  BSF    03.5
114C:  MOVWF  25
114D:  BCF    03.5
114E:  MOVF   43,W
114F:  BSF    03.5
1150:  MOVWF  24
1151:  MOVLW  DB
1152:  MOVWF  2B
1153:  MOVLW  0F
1154:  MOVWF  2A
1155:  MOVLW  49
1156:  MOVWF  29
1157:  MOVLW  80
1158:  MOVWF  28
1159:  BCF    0A.4
115A:  BCF    03.5
115B:  BCF    03.6
115C:  CALL   058
115D:  BSF    0A.4
115E:  BTFSC  2B.7
115F:  BSF    0B.7
1160:  BSF    03.6
1161:  MOVF   47,W
1162:  MOVWF  04
1163:  BCF    03.7
1164:  BTFSC  48.0
1165:  BSF    03.7
1166:  MOVF   7A,W
1167:  MOVWF  46
1168:  MOVF   79,W
1169:  MOVWF  45
116A:  MOVF   78,W
116B:  MOVWF  44
116C:  MOVF   77,W
116D:  MOVWF  43
116E:  MOVF   46,W
116F:  BSF    03.5
1170:  MOVWF  13
1171:  BCF    03.5
1172:  MOVF   45,W
1173:  BSF    03.5
1174:  MOVWF  12
1175:  BCF    03.5
1176:  MOVF   44,W
1177:  BSF    03.5
1178:  MOVWF  11
1179:  BCF    03.5
117A:  MOVF   43,W
117B:  BSF    03.5
117C:  MOVWF  10
117D:  CLRF   17
117E:  CLRF   16
117F:  MOVLW  34
1180:  MOVWF  15
1181:  MOVLW  86
1182:  MOVWF  14
1183:  BCF    0A.4
1184:  BCF    03.5
1185:  BCF    03.6
1186:  CALL   533
1187:  BSF    0A.4
1188:  MOVF   7A,W
1189:  BSF    03.6
118A:  MOVWF  46
118B:  MOVF   79,W
118C:  MOVWF  45
118D:  MOVF   78,W
118E:  MOVWF  44
118F:  MOVF   77,W
1190:  MOVWF  43
1191:  MOVF   46,W
1192:  BSF    03.5
1193:  MOVWF  13
1194:  BCF    03.5
1195:  MOVF   45,W
1196:  BSF    03.5
1197:  MOVWF  12
1198:  BCF    03.5
1199:  MOVF   44,W
119A:  BSF    03.5
119B:  MOVWF  11
119C:  BCF    03.5
119D:  MOVF   43,W
119E:  BSF    03.5
119F:  MOVWF  10
11A0:  MOVLW  DB
11A1:  MOVWF  17
11A2:  MOVLW  0F
11A3:  MOVWF  16
11A4:  MOVLW  49
11A5:  MOVWF  15
11A6:  MOVLW  80
11A7:  MOVWF  14
11A8:  BCF    0A.4
11A9:  BCF    03.5
11AA:  BCF    03.6
11AB:  CALL   465
11AC:  BSF    0A.4
11AD:  MOVF   7A,W
11AE:  BSF    03.5
11AF:  MOVWF  3F
11B0:  MOVF   79,W
11B1:  MOVWF  3E
11B2:  MOVF   78,W
11B3:  MOVWF  3D
11B4:  MOVF   77,W
11B5:  MOVWF  3C
....................    x_angle = accXangle; 
11B6:  MOVF   3F,W
11B7:  BCF    03.5
11B8:  MOVWF  40
11B9:  BSF    03.5
11BA:  MOVF   3E,W
11BB:  BCF    03.5
11BC:  MOVWF  3F
11BD:  BSF    03.5
11BE:  MOVF   3D,W
11BF:  BCF    03.5
11C0:  MOVWF  3E
11C1:  BSF    03.5
11C2:  MOVF   3C,W
11C3:  BCF    03.5
11C4:  MOVWF  3D
....................    gyroXangle = accXangle; 
11C5:  BSF    03.5
11C6:  MOVF   3F,W
11C7:  MOVWF  43
11C8:  MOVF   3E,W
11C9:  MOVWF  42
11CA:  MOVF   3D,W
11CB:  MOVWF  41
11CC:  MOVF   3C,W
11CD:  MOVWF  40
....................    delay_ms (500); 
11CE:  MOVLW  02
11CF:  BCF    03.5
11D0:  BSF    03.6
11D1:  MOVWF  43
11D2:  MOVLW  FA
11D3:  MOVWF  44
11D4:  BCF    0A.4
11D5:  BCF    03.6
11D6:  GOTO   747
11D7:  BSF    0A.4
11D8:  BSF    03.6
11D9:  DECFSZ 43,F
11DA:  GOTO   1D2
....................    set_tris_a (0); 
11DB:  MOVLW  00
11DC:  BSF    03.5
11DD:  BCF    03.6
11DE:  MOVWF  05
....................     
....................    WHILE (1) 
....................    { 
....................    
....................       IF (RX_Command_Ready == 1) //receive data processing take 4, 44ms 
11DF:  DECFSZ 56,W
11E0:  GOTO   452
....................       { 
.................... //!         disable_interrupts (GlOBAL); 
....................          output_toggle (PIN_B5); 
11E1:  BCF    06.5
11E2:  MOVLW  20
11E3:  BCF    03.5
11E4:  XORWF  06,F
....................          // ! printf ("\n % f ...", (FLOAT) get_ticks ()); receivemarker = 0; 
....................          // ! printf ("\n %.0f", (FLOAT) kp); 
....................          kp = 100 * ( (UNSIGNED int16) RxBuffer[6] - 48) + 10 * ((unsigned int16) RxBuffer[7] - 48) + (unsigned int16) RxBuffer[8] - 48; 
11E5:  BSF    03.6
11E6:  CLRF   44
11E7:  MOVF   16,W
11E8:  MOVWF  43
11E9:  MOVLW  30
11EA:  SUBWF  43,W
11EB:  MOVWF  77
11EC:  MOVF   44,W
11ED:  MOVWF  7A
11EE:  MOVLW  00
11EF:  BTFSS  03.0
11F0:  MOVLW  01
11F1:  SUBWF  7A,F
11F2:  MOVF   77,W
11F3:  MOVWF  43
11F4:  MOVF   7A,W
11F5:  MOVWF  44
11F6:  CLRF   48
11F7:  MOVLW  64
11F8:  MOVWF  47
11F9:  MOVF   44,W
11FA:  MOVWF  4A
11FB:  MOVF   43,W
11FC:  MOVWF  49
11FD:  BCF    0A.4
11FE:  BCF    03.6
11FF:  CALL   75E
1200:  BSF    0A.4
1201:  MOVF   79,W
1202:  BSF    03.6
1203:  MOVWF  44
1204:  MOVF   78,W
1205:  MOVWF  43
1206:  CLRF   46
1207:  MOVF   17,W
1208:  MOVWF  45
1209:  MOVLW  30
120A:  SUBWF  45,W
120B:  MOVWF  77
120C:  MOVF   46,W
120D:  MOVWF  7A
120E:  MOVLW  00
120F:  BTFSS  03.0
1210:  MOVLW  01
1211:  SUBWF  7A,F
1212:  MOVF   77,W
1213:  MOVWF  45
1214:  MOVF   7A,W
1215:  MOVWF  46
1216:  CLRF   48
1217:  MOVLW  0A
1218:  MOVWF  47
1219:  MOVF   46,W
121A:  MOVWF  4A
121B:  MOVF   45,W
121C:  MOVWF  49
121D:  BCF    0A.4
121E:  BCF    03.6
121F:  CALL   75E
1220:  BSF    0A.4
1221:  MOVF   79,W
1222:  MOVWF  7A
1223:  MOVF   78,W
1224:  BSF    03.6
1225:  ADDWF  43,F
1226:  MOVF   79,W
1227:  BTFSC  03.0
1228:  INCFSZ 79,W
1229:  ADDWF  44,F
122A:  CLRF   7A
122B:  MOVF   18,W
122C:  ADDWF  43,F
122D:  MOVF   7A,W
122E:  BTFSC  03.0
122F:  INCFSZ 7A,W
1230:  ADDWF  44,F
1231:  MOVLW  30
1232:  SUBWF  43,W
1233:  BCF    03.6
1234:  MOVWF  63
1235:  BSF    03.6
1236:  MOVF   44,W
1237:  BCF    03.6
1238:  MOVWF  64
1239:  MOVLW  00
123A:  BTFSS  03.0
123B:  MOVLW  01
123C:  SUBWF  64,F
....................          ki = 100 * ( (UNSIGNED int16) RxBuffer[9] - 48) + 10 * ((unsigned int16) RxBuffer[10] - 48) + (unsigned int16) RxBuffer[11] - 48; 
123D:  BSF    03.6
123E:  CLRF   44
123F:  MOVF   19,W
1240:  MOVWF  43
1241:  MOVLW  30
1242:  SUBWF  43,W
1243:  MOVWF  77
1244:  MOVF   44,W
1245:  MOVWF  7A
1246:  MOVLW  00
1247:  BTFSS  03.0
1248:  MOVLW  01
1249:  SUBWF  7A,F
124A:  MOVF   77,W
124B:  MOVWF  43
124C:  MOVF   7A,W
124D:  MOVWF  44
124E:  CLRF   48
124F:  MOVLW  64
1250:  MOVWF  47
1251:  MOVF   44,W
1252:  MOVWF  4A
1253:  MOVF   43,W
1254:  MOVWF  49
1255:  BCF    0A.4
1256:  BCF    03.6
1257:  CALL   75E
1258:  BSF    0A.4
1259:  MOVF   79,W
125A:  BSF    03.6
125B:  MOVWF  44
125C:  MOVF   78,W
125D:  MOVWF  43
125E:  CLRF   46
125F:  MOVF   1A,W
1260:  MOVWF  45
1261:  MOVLW  30
1262:  SUBWF  45,W
1263:  MOVWF  77
1264:  MOVF   46,W
1265:  MOVWF  7A
1266:  MOVLW  00
1267:  BTFSS  03.0
1268:  MOVLW  01
1269:  SUBWF  7A,F
126A:  MOVF   77,W
126B:  MOVWF  45
126C:  MOVF   7A,W
126D:  MOVWF  46
126E:  CLRF   48
126F:  MOVLW  0A
1270:  MOVWF  47
1271:  MOVF   46,W
1272:  MOVWF  4A
1273:  MOVF   45,W
1274:  MOVWF  49
1275:  BCF    0A.4
1276:  BCF    03.6
1277:  CALL   75E
1278:  BSF    0A.4
1279:  MOVF   79,W
127A:  MOVWF  7A
127B:  MOVF   78,W
127C:  BSF    03.6
127D:  ADDWF  43,F
127E:  MOVF   79,W
127F:  BTFSC  03.0
1280:  INCFSZ 79,W
1281:  ADDWF  44,F
1282:  CLRF   7A
1283:  MOVF   1B,W
1284:  ADDWF  43,F
1285:  MOVF   7A,W
1286:  BTFSC  03.0
1287:  INCFSZ 7A,W
1288:  ADDWF  44,F
1289:  MOVLW  30
128A:  SUBWF  43,W
128B:  BCF    03.6
128C:  MOVWF  65
128D:  BSF    03.6
128E:  MOVF   44,W
128F:  BCF    03.6
1290:  MOVWF  66
1291:  MOVLW  00
1292:  BTFSS  03.0
1293:  MOVLW  01
1294:  SUBWF  66,F
....................          kd = 100 * ( (UNSIGNED int16) RxBuffer[12] - 48) + 10 * ((unsigned int16) RxBuffer[13] - 48) + (unsigned int16) RxBuffer[14] - 48; 
1295:  BSF    03.6
1296:  CLRF   44
1297:  MOVF   1C,W
1298:  MOVWF  43
1299:  MOVLW  30
129A:  SUBWF  43,W
129B:  MOVWF  77
129C:  MOVF   44,W
129D:  MOVWF  7A
129E:  MOVLW  00
129F:  BTFSS  03.0
12A0:  MOVLW  01
12A1:  SUBWF  7A,F
12A2:  MOVF   77,W
12A3:  MOVWF  43
12A4:  MOVF   7A,W
12A5:  MOVWF  44
12A6:  CLRF   48
12A7:  MOVLW  64
12A8:  MOVWF  47
12A9:  MOVF   44,W
12AA:  MOVWF  4A
12AB:  MOVF   43,W
12AC:  MOVWF  49
12AD:  BCF    0A.4
12AE:  BCF    03.6
12AF:  CALL   75E
12B0:  BSF    0A.4
12B1:  MOVF   79,W
12B2:  BSF    03.6
12B3:  MOVWF  44
12B4:  MOVF   78,W
12B5:  MOVWF  43
12B6:  CLRF   46
12B7:  MOVF   1D,W
12B8:  MOVWF  45
12B9:  MOVLW  30
12BA:  SUBWF  45,W
12BB:  MOVWF  77
12BC:  MOVF   46,W
12BD:  MOVWF  7A
12BE:  MOVLW  00
12BF:  BTFSS  03.0
12C0:  MOVLW  01
12C1:  SUBWF  7A,F
12C2:  MOVF   77,W
12C3:  MOVWF  45
12C4:  MOVF   7A,W
12C5:  MOVWF  46
12C6:  CLRF   48
12C7:  MOVLW  0A
12C8:  MOVWF  47
12C9:  MOVF   46,W
12CA:  MOVWF  4A
12CB:  MOVF   45,W
12CC:  MOVWF  49
12CD:  BCF    0A.4
12CE:  BCF    03.6
12CF:  CALL   75E
12D0:  BSF    0A.4
12D1:  MOVF   79,W
12D2:  MOVWF  7A
12D3:  MOVF   78,W
12D4:  BSF    03.6
12D5:  ADDWF  43,F
12D6:  MOVF   79,W
12D7:  BTFSC  03.0
12D8:  INCFSZ 79,W
12D9:  ADDWF  44,F
12DA:  CLRF   7A
12DB:  MOVF   1E,W
12DC:  ADDWF  43,F
12DD:  MOVF   7A,W
12DE:  BTFSC  03.0
12DF:  INCFSZ 7A,W
12E0:  ADDWF  44,F
12E1:  MOVLW  30
12E2:  SUBWF  43,W
12E3:  BCF    03.6
12E4:  MOVWF  67
12E5:  BSF    03.6
12E6:  MOVF   44,W
12E7:  BCF    03.6
12E8:  MOVWF  68
12E9:  MOVLW  00
12EA:  BTFSS  03.0
12EB:  MOVLW  01
12EC:  SUBWF  68,F
....................          double temppo = 10000 * ( (UNSIGNED int16) RxBuffer[15] - 48) + 1000 * ((unsigned int16) RxBuffer[16] - 48)  
....................          +100 * ( (UNSIGNED int16) RxBuffer[17] - 48) + 10 * ((unsigned int16) RxBuffer[18] - 48) + (unsigned int16) RxBuffer[19] - 48; 
12ED:  BSF    03.6
12EE:  CLRF   44
12EF:  MOVF   1F,W
12F0:  MOVWF  43
12F1:  MOVLW  30
12F2:  SUBWF  43,W
12F3:  MOVWF  77
12F4:  MOVF   44,W
12F5:  MOVWF  7A
12F6:  MOVLW  00
12F7:  BTFSS  03.0
12F8:  MOVLW  01
12F9:  SUBWF  7A,F
12FA:  MOVF   77,W
12FB:  MOVWF  43
12FC:  MOVF   7A,W
12FD:  MOVWF  44
12FE:  MOVLW  27
12FF:  MOVWF  48
1300:  MOVLW  10
1301:  MOVWF  47
1302:  MOVF   44,W
1303:  MOVWF  4A
1304:  MOVF   43,W
1305:  MOVWF  49
1306:  BCF    0A.4
1307:  BCF    03.6
1308:  CALL   75E
1309:  BSF    0A.4
130A:  MOVF   79,W
130B:  BSF    03.6
130C:  MOVWF  44
130D:  MOVF   78,W
130E:  MOVWF  43
130F:  CLRF   46
1310:  MOVF   20,W
1311:  MOVWF  45
1312:  MOVLW  30
1313:  SUBWF  45,W
1314:  MOVWF  77
1315:  MOVF   46,W
1316:  MOVWF  7A
1317:  MOVLW  00
1318:  BTFSS  03.0
1319:  MOVLW  01
131A:  SUBWF  7A,F
131B:  MOVF   77,W
131C:  MOVWF  45
131D:  MOVF   7A,W
131E:  MOVWF  46
131F:  MOVLW  03
1320:  MOVWF  48
1321:  MOVLW  E8
1322:  MOVWF  47
1323:  MOVF   46,W
1324:  MOVWF  4A
1325:  MOVF   45,W
1326:  MOVWF  49
1327:  BCF    0A.4
1328:  BCF    03.6
1329:  CALL   75E
132A:  BSF    0A.4
132B:  MOVF   78,W
132C:  BSF    03.6
132D:  ADDWF  43,F
132E:  MOVF   79,W
132F:  BTFSC  03.0
1330:  INCFSZ 79,W
1331:  ADDWF  44,F
1332:  CLRF   46
1333:  MOVF   21,W
1334:  MOVWF  45
1335:  MOVLW  30
1336:  SUBWF  45,W
1337:  MOVWF  77
1338:  MOVF   46,W
1339:  MOVWF  7A
133A:  MOVLW  00
133B:  BTFSS  03.0
133C:  MOVLW  01
133D:  SUBWF  7A,F
133E:  MOVF   77,W
133F:  MOVWF  45
1340:  MOVF   7A,W
1341:  MOVWF  46
1342:  CLRF   48
1343:  MOVLW  64
1344:  MOVWF  47
1345:  MOVF   46,W
1346:  MOVWF  4A
1347:  MOVF   45,W
1348:  MOVWF  49
1349:  BCF    0A.4
134A:  BCF    03.6
134B:  CALL   75E
134C:  BSF    0A.4
134D:  MOVF   78,W
134E:  BSF    03.6
134F:  ADDWF  43,F
1350:  MOVF   79,W
1351:  BTFSC  03.0
1352:  INCFSZ 79,W
1353:  ADDWF  44,F
1354:  CLRF   46
1355:  MOVF   22,W
1356:  MOVWF  45
1357:  MOVLW  30
1358:  SUBWF  45,W
1359:  MOVWF  77
135A:  MOVF   46,W
135B:  MOVWF  7A
135C:  MOVLW  00
135D:  BTFSS  03.0
135E:  MOVLW  01
135F:  SUBWF  7A,F
1360:  MOVF   77,W
1361:  MOVWF  45
1362:  MOVF   7A,W
1363:  MOVWF  46
1364:  CLRF   48
1365:  MOVLW  0A
1366:  MOVWF  47
1367:  MOVF   46,W
1368:  MOVWF  4A
1369:  MOVF   45,W
136A:  MOVWF  49
136B:  BCF    0A.4
136C:  BCF    03.6
136D:  CALL   75E
136E:  BSF    0A.4
136F:  MOVF   79,W
1370:  MOVWF  7A
1371:  MOVF   78,W
1372:  BSF    03.6
1373:  ADDWF  43,F
1374:  MOVF   79,W
1375:  BTFSC  03.0
1376:  INCFSZ 79,W
1377:  ADDWF  44,F
1378:  CLRF   7A
1379:  MOVF   23,W
137A:  ADDWF  43,F
137B:  MOVF   7A,W
137C:  BTFSC  03.0
137D:  INCFSZ 7A,W
137E:  ADDWF  44,F
137F:  MOVLW  30
1380:  SUBWF  43,W
1381:  MOVWF  77
1382:  MOVF   44,W
1383:  MOVWF  7A
1384:  MOVLW  00
1385:  BTFSS  03.0
1386:  MOVLW  01
1387:  SUBWF  7A,F
1388:  MOVF   77,W
1389:  MOVWF  43
138A:  MOVF   7A,W
138B:  MOVWF  44
138C:  BCF    0A.4
138D:  BCF    03.6
138E:  GOTO   775
138F:  BSF    0A.4
1390:  MOVF   7A,W
1391:  BSF    03.6
1392:  MOVWF  3D
1393:  MOVF   79,W
1394:  MOVWF  3C
1395:  MOVF   78,W
1396:  MOVWF  3B
1397:  MOVF   77,W
1398:  MOVWF  3A
....................          setpoint=temppo/100; 
1399:  MOVF   3D,W
139A:  BSF    03.5
139B:  MOVWF  13
139C:  BCF    03.5
139D:  MOVF   3C,W
139E:  BSF    03.5
139F:  MOVWF  12
13A0:  BCF    03.5
13A1:  MOVF   3B,W
13A2:  BSF    03.5
13A3:  MOVWF  11
13A4:  BCF    03.5
13A5:  MOVF   3A,W
13A6:  BSF    03.5
13A7:  MOVWF  10
13A8:  CLRF   17
13A9:  CLRF   16
13AA:  MOVLW  48
13AB:  MOVWF  15
13AC:  MOVLW  85
13AD:  MOVWF  14
13AE:  BCF    0A.4
13AF:  BCF    03.5
13B0:  BCF    03.6
13B1:  CALL   465
13B2:  BSF    0A.4
13B3:  MOVF   7A,W
13B4:  MOVWF  74
13B5:  MOVF   79,W
13B6:  MOVWF  73
13B7:  MOVF   78,W
13B8:  MOVWF  72
13B9:  MOVF   77,W
13BA:  MOVWF  71
....................          for (INT i = 0; i < RX_SIZE; i++) 
13BB:  BSF    03.6
13BC:  CLRF   3E
13BD:  MOVF   3E,W
13BE:  SUBLW  27
13BF:  BTFSS  03.0
13C0:  GOTO   3C8
....................          { 
....................             RxBuffer[i] = '\0'; 
13C1:  MOVLW  10
13C2:  ADDWF  3E,W
13C3:  MOVWF  04
13C4:  BSF    03.7
13C5:  CLRF   00
13C6:  INCF   3E,F
13C7:  GOTO   3BD
....................          } 
....................  
....................          RX_Command_Ready = 0; 
13C8:  BSF    03.5
13C9:  BCF    03.6
13CA:  CLRF   56
....................          // ! printf ("\n % f ", (FLOAT) get_ticks ()); 
....................          printf (" \n < $%.2f$ $%.2f$ $%.2f$ > ", (FLOAT) inputt, (FLOAT) setpoint, (float) offsetGyro); 
13CB:  MOVLW  3B
13CC:  BCF    03.5
13CD:  BSF    03.6
13CE:  MOVWF  0D
13CF:  MOVLW  02
13D0:  MOVWF  0F
13D1:  BCF    03.0
13D2:  MOVLW  06
13D3:  MOVWF  43
13D4:  BCF    0A.4
13D5:  BCF    03.6
13D6:  CALL   796
13D7:  BSF    0A.4
13D8:  MOVLW  89
13D9:  MOVWF  04
13DA:  BSF    03.5
13DB:  MOVF   23,W
13DC:  BCF    03.5
13DD:  BSF    03.6
13DE:  MOVWF  46
13DF:  BSF    03.5
13E0:  BCF    03.6
13E1:  MOVF   22,W
13E2:  BCF    03.5
13E3:  BSF    03.6
13E4:  MOVWF  45
13E5:  BSF    03.5
13E6:  BCF    03.6
13E7:  MOVF   21,W
13E8:  BCF    03.5
13E9:  BSF    03.6
13EA:  MOVWF  44
13EB:  BSF    03.5
13EC:  BCF    03.6
13ED:  MOVF   20,W
13EE:  BCF    03.5
13EF:  BSF    03.6
13F0:  MOVWF  43
13F1:  MOVLW  02
13F2:  MOVWF  47
13F3:  BCF    0A.4
13F4:  BSF    0A.3
13F5:  BCF    03.6
13F6:  CALL   476
13F7:  BSF    0A.4
13F8:  BCF    0A.3
13F9:  MOVLW  24
13FA:  BTFSS  0C.4
13FB:  GOTO   3FA
13FC:  MOVWF  19
13FD:  MOVLW  20
13FE:  BTFSS  0C.4
13FF:  GOTO   3FE
1400:  MOVWF  19
1401:  MOVLW  24
1402:  BTFSS  0C.4
1403:  GOTO   402
1404:  MOVWF  19
1405:  MOVLW  89
1406:  MOVWF  04
1407:  MOVF   74,W
1408:  BSF    03.6
1409:  MOVWF  46
140A:  MOVF   73,W
140B:  MOVWF  45
140C:  MOVF   72,W
140D:  MOVWF  44
140E:  MOVF   71,W
140F:  MOVWF  43
1410:  MOVLW  02
1411:  MOVWF  47
1412:  BCF    0A.4
1413:  BSF    0A.3
1414:  BCF    03.6
1415:  CALL   476
1416:  BSF    0A.4
1417:  BCF    0A.3
1418:  MOVLW  24
1419:  BTFSS  0C.4
141A:  GOTO   419
141B:  MOVWF  19
141C:  MOVLW  20
141D:  BTFSS  0C.4
141E:  GOTO   41D
141F:  MOVWF  19
1420:  MOVLW  24
1421:  BTFSS  0C.4
1422:  GOTO   421
1423:  MOVWF  19
1424:  MOVLW  89
1425:  MOVWF  04
1426:  BSF    03.5
1427:  MOVF   55,W
1428:  BCF    03.5
1429:  BSF    03.6
142A:  MOVWF  46
142B:  BSF    03.5
142C:  BCF    03.6
142D:  MOVF   54,W
142E:  BCF    03.5
142F:  BSF    03.6
1430:  MOVWF  45
1431:  BSF    03.5
1432:  BCF    03.6
1433:  MOVF   53,W
1434:  BCF    03.5
1435:  BSF    03.6
1436:  MOVWF  44
1437:  BSF    03.5
1438:  BCF    03.6
1439:  MOVF   52,W
143A:  BCF    03.5
143B:  BSF    03.6
143C:  MOVWF  43
143D:  MOVLW  02
143E:  MOVWF  47
143F:  BCF    0A.4
1440:  BSF    0A.3
1441:  BCF    03.6
1442:  CALL   476
1443:  BSF    0A.4
1444:  BCF    0A.3
1445:  MOVLW  47
1446:  BSF    03.6
1447:  MOVWF  0D
1448:  MOVLW  02
1449:  MOVWF  0F
144A:  BCF    03.0
144B:  MOVLW  04
144C:  MOVWF  43
144D:  BCF    0A.4
144E:  BCF    03.6
144F:  CALL   796
1450:  BSF    0A.4
1451:  BSF    03.5
.................... //!         printf (" \n <$%f$ $%f$ $%f$ $%.2f$ $%.2f$ $%.2f$ > ", (FLOAT) kp, (float) ki, (float) kd, (FLOAT) inputt, (FLOAT) setpoint, (float) offsetGyro); 
....................          // ! printf ("\n % f . ", (FLOAT) get_ticks ()); 
.................... //!         enable_interrupts (GlOBAL); 
....................       } 
....................  
....................        
....................       IF (firststate == 1) 
1452:  BCF    03.5
1453:  BSF    03.6
1454:  DECFSZ 38,W
1455:  GOTO   4F9
....................       { 
....................          IF (count >= 100) 
1456:  BSF    03.5
1457:  BCF    03.6
1458:  MOVF   4B,F
1459:  BTFSS  03.2
145A:  GOTO   45F
145B:  MOVF   4A,W
145C:  SUBLW  63
145D:  BTFSC  03.0
145E:  GOTO   4F7
....................          { 
....................             count = 0; 
145F:  CLRF   4B
1460:  CLRF   4A
....................             // ! printf ("\n % f", (FLOAT) (dumemay / 100)) ; 
....................             // ! printf (" % f", (FLOAT) inputt); 
....................              
....................             IF (co >= 13){countt += dumemay; } 
1461:  MOVF   51,W
1462:  SUBLW  0C
1463:  BTFSC  03.0
1464:  GOTO   49B
1465:  BCF    03.1
1466:  BCF    03.5
1467:  CLRF   2B
1468:  BTFSC  0B.7
1469:  BSF    2B.7
146A:  BCF    0B.7
146B:  BSF    03.5
146C:  MOVF   50,W
146D:  BSF    03.6
146E:  MOVWF  27
146F:  BCF    03.6
1470:  MOVF   4F,W
1471:  BSF    03.6
1472:  MOVWF  26
1473:  BCF    03.6
1474:  MOVF   4E,W
1475:  BSF    03.6
1476:  MOVWF  25
1477:  BCF    03.6
1478:  MOVF   4D,W
1479:  BSF    03.6
147A:  MOVWF  24
147B:  BCF    03.6
147C:  MOVF   2F,W
147D:  BSF    03.6
147E:  MOVWF  2B
147F:  BCF    03.6
1480:  MOVF   2E,W
1481:  BSF    03.6
1482:  MOVWF  2A
1483:  BCF    03.6
1484:  MOVF   2D,W
1485:  BSF    03.6
1486:  MOVWF  29
1487:  BCF    03.6
1488:  MOVF   2C,W
1489:  BSF    03.6
148A:  MOVWF  28
148B:  BCF    0A.4
148C:  BCF    03.5
148D:  BCF    03.6
148E:  CALL   058
148F:  BSF    0A.4
1490:  BTFSC  2B.7
1491:  BSF    0B.7
1492:  MOVF   7A,W
1493:  BSF    03.5
1494:  MOVWF  50
1495:  MOVF   79,W
1496:  MOVWF  4F
1497:  MOVF   78,W
1498:  MOVWF  4E
1499:  MOVF   77,W
149A:  MOVWF  4D
....................             co++; 
149B:  INCF   51,F
....................  
....................             IF (co >= 23) 
149C:  MOVF   51,W
149D:  SUBLW  16
149E:  BTFSC  03.0
149F:  GOTO   4F3
....................             { 
....................                offsetGyro = - 1 * countt / 1000; countt = 0; firststate = 0; count = 0; 
14A0:  BSF    03.6
14A1:  CLRF   13
14A2:  CLRF   12
14A3:  MOVLW  80
14A4:  MOVWF  11
14A5:  MOVLW  7F
14A6:  MOVWF  10
14A7:  BCF    03.6
14A8:  MOVF   50,W
14A9:  BSF    03.6
14AA:  MOVWF  17
14AB:  BCF    03.6
14AC:  MOVF   4F,W
14AD:  BSF    03.6
14AE:  MOVWF  16
14AF:  BCF    03.6
14B0:  MOVF   4E,W
14B1:  BSF    03.6
14B2:  MOVWF  15
14B3:  BCF    03.6
14B4:  MOVF   4D,W
14B5:  BSF    03.6
14B6:  MOVWF  14
14B7:  BCF    0A.4
14B8:  BCF    03.5
14B9:  BCF    03.6
14BA:  CALL   533
14BB:  BSF    0A.4
14BC:  MOVF   7A,W
14BD:  BSF    03.6
14BE:  MOVWF  46
14BF:  MOVF   79,W
14C0:  MOVWF  45
14C1:  MOVF   78,W
14C2:  MOVWF  44
14C3:  MOVF   77,W
14C4:  MOVWF  43
14C5:  MOVF   46,W
14C6:  BSF    03.5
14C7:  MOVWF  13
14C8:  BCF    03.5
14C9:  MOVF   45,W
14CA:  BSF    03.5
14CB:  MOVWF  12
14CC:  BCF    03.5
14CD:  MOVF   44,W
14CE:  BSF    03.5
14CF:  MOVWF  11
14D0:  BCF    03.5
14D1:  MOVF   43,W
14D2:  BSF    03.5
14D3:  MOVWF  10
14D4:  CLRF   17
14D5:  CLRF   16
14D6:  MOVLW  7A
14D7:  MOVWF  15
14D8:  MOVLW  88
14D9:  MOVWF  14
14DA:  BCF    0A.4
14DB:  BCF    03.5
14DC:  BCF    03.6
14DD:  CALL   465
14DE:  BSF    0A.4
14DF:  MOVF   7A,W
14E0:  BSF    03.5
14E1:  MOVWF  55
14E2:  MOVF   79,W
14E3:  MOVWF  54
14E4:  MOVF   78,W
14E5:  MOVWF  53
14E6:  MOVF   77,W
14E7:  MOVWF  52
14E8:  CLRF   50
14E9:  CLRF   4F
14EA:  CLRF   4E
14EB:  CLRF   4D
14EC:  BCF    03.5
14ED:  BSF    03.6
14EE:  CLRF   38
14EF:  BSF    03.5
14F0:  BCF    03.6
14F1:  CLRF   4B
14F2:  CLRF   4A
....................             } 
....................  
....................             dumemay = 0; 
14F3:  CLRF   2F
14F4:  CLRF   2E
14F5:  CLRF   2D
14F6:  CLRF   2C
....................          } 
....................       } 
14F7:  BCF    03.5
14F8:  BSF    03.6
....................  
....................       ELSE 
....................       { 
.................... //!         UNSIGNED int outspeed = move ( (output), 10) ; 
....................           
....................          //! 
....................          // !  IF (cc == 'c') 
....................          // ! 
.................... //!         { 
....................             // !  // printf (" < $ % f$ $ % f$ $ % f$ $ % .2f$ $ % .2f $ $ % .2f $ > ", (FLOAT) kp, (float) ki, (float) kd, (FLOAT) inputt, (FLOAT) originalSetpoint, (float) offsetGyro); 
....................             // !   index++; 
....................             // !   output_toggle (PIN_B5) ; 
....................             // !   senddata = 0; 
....................             // !   cc = '0'; 
....................             // !  for (INT i = 0; i < 8; i++) RxBuffer[i] = '0'; 
....................             // ! 
.................... //!         } 
....................       } 
....................  
....................       IF ( (get_ticks () - testtimer) >25) 
14F9:  BCF    0A.4
14FA:  BSF    0A.3
14FB:  BCF    03.6
14FC:  CALL   578
14FD:  BSF    0A.4
14FE:  BCF    0A.3
14FF:  BSF    03.5
1500:  MOVF   58,W
1501:  SUBWF  77,W
1502:  BCF    03.5
1503:  BSF    03.6
1504:  MOVWF  43
1505:  CLRF   44
1506:  BSF    03.5
1507:  BCF    03.6
1508:  MOVF   59,W
1509:  BTFSS  03.0
150A:  INCFSZ 59,W
150B:  GOTO   50D
150C:  GOTO   512
150D:  BCF    03.5
150E:  BSF    03.6
150F:  SUBWF  44,F
1510:  BSF    03.5
1511:  BCF    03.6
1512:  BCF    03.5
1513:  BSF    03.6
1514:  MOVF   44,F
1515:  BTFSS  03.2
1516:  GOTO   51B
1517:  MOVF   43,W
1518:  SUBLW  19
1519:  BTFSC  03.0
151A:  GOTO   7C9
....................       { 
....................  
....................          testtimer=get_ticks(); 
151B:  BCF    0A.4
151C:  BSF    0A.3
151D:  BCF    03.6
151E:  CALL   578
151F:  BSF    0A.4
1520:  BCF    0A.3
1521:  BSF    03.5
1522:  CLRF   59
1523:  MOVF   77,W
1524:  MOVWF  58
....................          accX = Mpu6050_GetData (MPU6050_RA_ACCEL_XOUT_H) ; 
1525:  MOVLW  3B
1526:  BCF    03.5
1527:  BSF    03.6
1528:  MOVWF  43
1529:  BCF    0A.4
152A:  BCF    03.6
152B:  CALL   377
152C:  BSF    0A.4
152D:  MOVF   79,W
152E:  BSF    03.5
152F:  MOVWF  31
1530:  MOVF   78,W
1531:  MOVWF  30
....................          accY = Mpu6050_GetData (MPU6050_RA_ACCEL_YOUT_H) ; 
1532:  MOVLW  3D
1533:  BCF    03.5
1534:  BSF    03.6
1535:  MOVWF  43
1536:  BCF    0A.4
1537:  BCF    03.6
1538:  CALL   377
1539:  BSF    0A.4
153A:  MOVF   79,W
153B:  BSF    03.5
153C:  MOVWF  33
153D:  MOVF   78,W
153E:  MOVWF  32
....................          accZ = Mpu6050_GetData (MPU6050_RA_ACCEL_ZOUT_H) ; 
153F:  MOVLW  3F
1540:  BCF    03.5
1541:  BSF    03.6
1542:  MOVWF  43
1543:  BCF    0A.4
1544:  BCF    03.6
1545:  CALL   377
1546:  BSF    0A.4
1547:  MOVF   79,W
1548:  BSF    03.5
1549:  MOVWF  35
154A:  MOVF   78,W
154B:  MOVWF  34
....................          gyroX = Mpu6050_GetData (MPU6050_RA_GYRO_XOUT_H) ; 
154C:  MOVLW  43
154D:  BCF    03.5
154E:  BSF    03.6
154F:  MOVWF  43
1550:  BCF    0A.4
1551:  BCF    03.6
1552:  CALL   377
1553:  BSF    0A.4
1554:  MOVF   79,W
1555:  BSF    03.5
1556:  MOVWF  37
1557:  MOVF   78,W
1558:  MOVWF  36
....................          gyroY = Mpu6050_GetData (MPU6050_RA_GYRO_YOUT_H) ; 
1559:  MOVLW  45
155A:  BCF    03.5
155B:  BSF    03.6
155C:  MOVWF  43
155D:  BCF    0A.4
155E:  BCF    03.6
155F:  CALL   377
1560:  BSF    0A.4
1561:  MOVF   79,W
1562:  BSF    03.5
1563:  MOVWF  39
1564:  MOVF   78,W
1565:  MOVWF  38
....................          gyroZ = Mpu6050_GetData (MPU6050_RA_GYRO_ZOUT_H) ; 
1566:  MOVLW  47
1567:  BCF    03.5
1568:  BSF    03.6
1569:  MOVWF  43
156A:  BCF    0A.4
156B:  BCF    03.6
156C:  CALL   377
156D:  BSF    0A.4
156E:  MOVF   79,W
156F:  BSF    03.5
1570:  MOVWF  3B
1571:  MOVF   78,W
1572:  MOVWF  3A
....................          accXangle = (atan2 (accY, accZ) + PI) * RAD_TO_DEG; 
1573:  MOVF   33,W
1574:  BCF    03.5
1575:  BSF    03.6
1576:  MOVWF  48
1577:  BSF    03.5
1578:  BCF    03.6
1579:  MOVF   32,W
157A:  BCF    03.5
157B:  BSF    03.6
157C:  MOVWF  47
157D:  BCF    0A.4
157E:  BCF    03.6
157F:  CALL   3F3
1580:  BSF    0A.4
1581:  MOVF   7A,W
1582:  BSF    03.6
1583:  MOVWF  46
1584:  MOVF   79,W
1585:  MOVWF  45
1586:  MOVF   78,W
1587:  MOVWF  44
1588:  MOVF   77,W
1589:  MOVWF  43
158A:  BSF    03.5
158B:  BCF    03.6
158C:  MOVF   35,W
158D:  BCF    03.5
158E:  BSF    03.6
158F:  MOVWF  48
1590:  BSF    03.5
1591:  BCF    03.6
1592:  MOVF   34,W
1593:  BCF    03.5
1594:  BSF    03.6
1595:  MOVWF  47
1596:  BCF    0A.4
1597:  BCF    03.6
1598:  CALL   3F3
1599:  BSF    0A.4
159A:  MOVF   7A,W
159B:  BSF    03.6
159C:  MOVWF  4A
159D:  MOVF   79,W
159E:  MOVWF  49
159F:  MOVF   78,W
15A0:  MOVWF  48
15A1:  MOVF   77,W
15A2:  MOVWF  47
15A3:  MOVF   46,W
15A4:  MOVWF  4E
15A5:  MOVF   45,W
15A6:  MOVWF  4D
15A7:  MOVF   44,W
15A8:  MOVWF  4C
15A9:  MOVF   43,W
15AA:  MOVWF  4B
15AB:  MOVF   4A,W
15AC:  MOVWF  52
15AD:  MOVF   49,W
15AE:  MOVWF  51
15AF:  MOVF   48,W
15B0:  MOVWF  50
15B1:  MOVF   47,W
15B2:  MOVWF  4F
15B3:  BCF    0A.4
15B4:  BCF    03.6
15B5:  CALL   5AC
15B6:  BSF    0A.4
15B7:  MOVF   7A,W
15B8:  BSF    03.6
15B9:  MOVWF  46
15BA:  MOVF   79,W
15BB:  MOVWF  45
15BC:  MOVF   78,W
15BD:  MOVWF  44
15BE:  MOVF   77,W
15BF:  MOVWF  43
15C0:  CLRF   48
15C1:  MOVF   04,W
15C2:  MOVWF  47
15C3:  BCF    48.0
15C4:  BTFSC  03.7
15C5:  BSF    48.0
15C6:  BCF    03.1
15C7:  BCF    03.6
15C8:  CLRF   2B
15C9:  BTFSC  0B.7
15CA:  BSF    2B.7
15CB:  BCF    0B.7
15CC:  BSF    03.6
15CD:  MOVF   46,W
15CE:  BSF    03.5
15CF:  MOVWF  27
15D0:  BCF    03.5
15D1:  MOVF   45,W
15D2:  BSF    03.5
15D3:  MOVWF  26
15D4:  BCF    03.5
15D5:  MOVF   44,W
15D6:  BSF    03.5
15D7:  MOVWF  25
15D8:  BCF    03.5
15D9:  MOVF   43,W
15DA:  BSF    03.5
15DB:  MOVWF  24
15DC:  MOVLW  DB
15DD:  MOVWF  2B
15DE:  MOVLW  0F
15DF:  MOVWF  2A
15E0:  MOVLW  49
15E1:  MOVWF  29
15E2:  MOVLW  80
15E3:  MOVWF  28
15E4:  BCF    0A.4
15E5:  BCF    03.5
15E6:  BCF    03.6
15E7:  CALL   058
15E8:  BSF    0A.4
15E9:  BTFSC  2B.7
15EA:  BSF    0B.7
15EB:  BSF    03.6
15EC:  MOVF   47,W
15ED:  MOVWF  04
15EE:  BCF    03.7
15EF:  BTFSC  48.0
15F0:  BSF    03.7
15F1:  MOVF   7A,W
15F2:  MOVWF  46
15F3:  MOVF   79,W
15F4:  MOVWF  45
15F5:  MOVF   78,W
15F6:  MOVWF  44
15F7:  MOVF   77,W
15F8:  MOVWF  43
15F9:  MOVF   46,W
15FA:  BSF    03.5
15FB:  MOVWF  13
15FC:  BCF    03.5
15FD:  MOVF   45,W
15FE:  BSF    03.5
15FF:  MOVWF  12
1600:  BCF    03.5
1601:  MOVF   44,W
1602:  BSF    03.5
1603:  MOVWF  11
1604:  BCF    03.5
1605:  MOVF   43,W
1606:  BSF    03.5
1607:  MOVWF  10
1608:  CLRF   17
1609:  CLRF   16
160A:  MOVLW  34
160B:  MOVWF  15
160C:  MOVLW  86
160D:  MOVWF  14
160E:  BCF    0A.4
160F:  BCF    03.5
1610:  BCF    03.6
1611:  CALL   533
1612:  BSF    0A.4
1613:  MOVF   7A,W
1614:  BSF    03.6
1615:  MOVWF  46
1616:  MOVF   79,W
1617:  MOVWF  45
1618:  MOVF   78,W
1619:  MOVWF  44
161A:  MOVF   77,W
161B:  MOVWF  43
161C:  MOVF   46,W
161D:  BSF    03.5
161E:  MOVWF  13
161F:  BCF    03.5
1620:  MOVF   45,W
1621:  BSF    03.5
1622:  MOVWF  12
1623:  BCF    03.5
1624:  MOVF   44,W
1625:  BSF    03.5
1626:  MOVWF  11
1627:  BCF    03.5
1628:  MOVF   43,W
1629:  BSF    03.5
162A:  MOVWF  10
162B:  MOVLW  DB
162C:  MOVWF  17
162D:  MOVLW  0F
162E:  MOVWF  16
162F:  MOVLW  49
1630:  MOVWF  15
1631:  MOVLW  80
1632:  MOVWF  14
1633:  BCF    0A.4
1634:  BCF    03.5
1635:  BCF    03.6
1636:  CALL   465
1637:  BSF    0A.4
1638:  MOVF   7A,W
1639:  BSF    03.5
163A:  MOVWF  3F
163B:  MOVF   79,W
163C:  MOVWF  3E
163D:  MOVF   78,W
163E:  MOVWF  3D
163F:  MOVF   77,W
1640:  MOVWF  3C
....................          DOUBLE gyroXrate = (double) (gyroX + offsetGyro) / 131.0;//313.4 / 303.5 / 
1641:  MOVF   37,W
1642:  BCF    03.5
1643:  BSF    03.6
1644:  MOVWF  48
1645:  BSF    03.5
1646:  BCF    03.6
1647:  MOVF   36,W
1648:  BCF    03.5
1649:  BSF    03.6
164A:  MOVWF  47
164B:  BCF    0A.4
164C:  BCF    03.6
164D:  CALL   3F3
164E:  BSF    0A.4
164F:  BCF    03.1
1650:  CLRF   2B
1651:  BTFSC  0B.7
1652:  BSF    2B.7
1653:  BCF    0B.7
1654:  MOVF   7A,W
1655:  BSF    03.5
1656:  BSF    03.6
1657:  MOVWF  27
1658:  MOVF   79,W
1659:  MOVWF  26
165A:  MOVF   78,W
165B:  MOVWF  25
165C:  MOVF   77,W
165D:  MOVWF  24
165E:  BCF    03.6
165F:  MOVF   55,W
1660:  BSF    03.6
1661:  MOVWF  2B
1662:  BCF    03.6
1663:  MOVF   54,W
1664:  BSF    03.6
1665:  MOVWF  2A
1666:  BCF    03.6
1667:  MOVF   53,W
1668:  BSF    03.6
1669:  MOVWF  29
166A:  BCF    03.6
166B:  MOVF   52,W
166C:  BSF    03.6
166D:  MOVWF  28
166E:  BCF    0A.4
166F:  BCF    03.5
1670:  BCF    03.6
1671:  CALL   058
1672:  BSF    0A.4
1673:  BTFSC  2B.7
1674:  BSF    0B.7
1675:  MOVF   7A,W
1676:  BSF    03.6
1677:  MOVWF  46
1678:  MOVF   79,W
1679:  MOVWF  45
167A:  MOVF   78,W
167B:  MOVWF  44
167C:  MOVF   77,W
167D:  MOVWF  43
167E:  MOVF   46,W
167F:  BSF    03.5
1680:  MOVWF  13
1681:  BCF    03.5
1682:  MOVF   45,W
1683:  BSF    03.5
1684:  MOVWF  12
1685:  BCF    03.5
1686:  MOVF   44,W
1687:  BSF    03.5
1688:  MOVWF  11
1689:  BCF    03.5
168A:  MOVF   43,W
168B:  BSF    03.5
168C:  MOVWF  10
168D:  CLRF   17
168E:  CLRF   16
168F:  MOVLW  03
1690:  MOVWF  15
1691:  MOVLW  86
1692:  MOVWF  14
1693:  BCF    0A.4
1694:  BCF    03.5
1695:  BCF    03.6
1696:  CALL   465
1697:  BSF    0A.4
1698:  MOVF   7A,W
1699:  BSF    03.6
169A:  MOVWF  42
169B:  MOVF   79,W
169C:  MOVWF  41
169D:  MOVF   78,W
169E:  MOVWF  40
169F:  MOVF   77,W
16A0:  MOVWF  3F
.................... //!         if(firststate==1) 
.................... //!         { 
....................          dumemay += gyroX; 
16A1:  BSF    03.5
16A2:  BCF    03.6
16A3:  MOVF   37,W
16A4:  BCF    03.5
16A5:  BSF    03.6
16A6:  MOVWF  48
16A7:  BSF    03.5
16A8:  BCF    03.6
16A9:  MOVF   36,W
16AA:  BCF    03.5
16AB:  BSF    03.6
16AC:  MOVWF  47
16AD:  BCF    0A.4
16AE:  BCF    03.6
16AF:  CALL   3F3
16B0:  BSF    0A.4
16B1:  BCF    03.1
16B2:  CLRF   2B
16B3:  BTFSC  0B.7
16B4:  BSF    2B.7
16B5:  BCF    0B.7
16B6:  BSF    03.5
16B7:  MOVF   2F,W
16B8:  BSF    03.6
16B9:  MOVWF  27
16BA:  BCF    03.6
16BB:  MOVF   2E,W
16BC:  BSF    03.6
16BD:  MOVWF  26
16BE:  BCF    03.6
16BF:  MOVF   2D,W
16C0:  BSF    03.6
16C1:  MOVWF  25
16C2:  BCF    03.6
16C3:  MOVF   2C,W
16C4:  BSF    03.6
16C5:  MOVWF  24
16C6:  MOVF   7A,W
16C7:  MOVWF  2B
16C8:  MOVF   79,W
16C9:  MOVWF  2A
16CA:  MOVF   78,W
16CB:  MOVWF  29
16CC:  MOVF   77,W
16CD:  MOVWF  28
16CE:  BCF    0A.4
16CF:  BCF    03.5
16D0:  BCF    03.6
16D1:  CALL   058
16D2:  BSF    0A.4
16D3:  BTFSC  2B.7
16D4:  BSF    0B.7
16D5:  MOVF   7A,W
16D6:  BSF    03.5
16D7:  MOVWF  2F
16D8:  MOVF   79,W
16D9:  MOVWF  2E
16DA:  MOVF   78,W
16DB:  MOVWF  2D
16DC:  MOVF   77,W
16DD:  MOVWF  2C
....................          count++; 
16DE:  INCF   4A,F
16DF:  BTFSC  03.2
16E0:  INCF   4B,F
....................           
....................          gyroXangle += gyroXrate * 10 / 1000; // ( (DOUBLE) (get_ticks () - timer) / 1000) , 10ms 
16E1:  BCF    03.5
16E2:  BSF    03.6
16E3:  MOVF   42,W
16E4:  BSF    03.5
16E5:  MOVWF  13
16E6:  BCF    03.5
16E7:  MOVF   41,W
16E8:  BSF    03.5
16E9:  MOVWF  12
16EA:  BCF    03.5
16EB:  MOVF   40,W
16EC:  BSF    03.5
16ED:  MOVWF  11
16EE:  BCF    03.5
16EF:  MOVF   3F,W
16F0:  BSF    03.5
16F1:  MOVWF  10
16F2:  CLRF   17
16F3:  CLRF   16
16F4:  MOVLW  20
16F5:  MOVWF  15
16F6:  MOVLW  82
16F7:  MOVWF  14
16F8:  BCF    0A.4
16F9:  BCF    03.5
16FA:  BCF    03.6
16FB:  CALL   533
16FC:  BSF    0A.4
16FD:  MOVF   7A,W
16FE:  BSF    03.6
16FF:  MOVWF  46
1700:  MOVF   79,W
1701:  MOVWF  45
1702:  MOVF   78,W
1703:  MOVWF  44
1704:  MOVF   77,W
1705:  MOVWF  43
1706:  MOVF   46,W
1707:  BSF    03.5
1708:  MOVWF  13
1709:  BCF    03.5
170A:  MOVF   45,W
170B:  BSF    03.5
170C:  MOVWF  12
170D:  BCF    03.5
170E:  MOVF   44,W
170F:  BSF    03.5
1710:  MOVWF  11
1711:  BCF    03.5
1712:  MOVF   43,W
1713:  BSF    03.5
1714:  MOVWF  10
1715:  CLRF   17
1716:  CLRF   16
1717:  MOVLW  7A
1718:  MOVWF  15
1719:  MOVLW  88
171A:  MOVWF  14
171B:  BCF    0A.4
171C:  BCF    03.5
171D:  BCF    03.6
171E:  CALL   465
171F:  BSF    0A.4
1720:  BCF    03.1
1721:  CLRF   2B
1722:  BTFSC  0B.7
1723:  BSF    2B.7
1724:  BCF    0B.7
1725:  BSF    03.5
1726:  MOVF   43,W
1727:  BSF    03.6
1728:  MOVWF  27
1729:  BCF    03.6
172A:  MOVF   42,W
172B:  BSF    03.6
172C:  MOVWF  26
172D:  BCF    03.6
172E:  MOVF   41,W
172F:  BSF    03.6
1730:  MOVWF  25
1731:  BCF    03.6
1732:  MOVF   40,W
1733:  BSF    03.6
1734:  MOVWF  24
1735:  MOVF   7A,W
1736:  MOVWF  2B
1737:  MOVF   79,W
1738:  MOVWF  2A
1739:  MOVF   78,W
173A:  MOVWF  29
173B:  MOVF   77,W
173C:  MOVWF  28
173D:  BCF    0A.4
173E:  BCF    03.5
173F:  BCF    03.6
1740:  CALL   058
1741:  BSF    0A.4
1742:  BTFSC  2B.7
1743:  BSF    0B.7
1744:  MOVF   7A,W
1745:  BSF    03.5
1746:  MOVWF  43
1747:  MOVF   79,W
1748:  MOVWF  42
1749:  MOVF   78,W
174A:  MOVWF  41
174B:  MOVF   77,W
174C:  MOVWF  40
....................           
....................          //kalAngleX = kalmanCalculate (accXangle, gyroXrate, 10); 
....................          compfilterAngleX = 0.02 * accXangle + 0.98 * gyroXangle; 
174D:  MOVLW  0A
174E:  BSF    03.6
174F:  MOVWF  13
1750:  MOVLW  D7
1751:  MOVWF  12
1752:  MOVLW  23
1753:  MOVWF  11
1754:  MOVLW  79
1755:  MOVWF  10
1756:  BCF    03.6
1757:  MOVF   3F,W
1758:  BSF    03.6
1759:  MOVWF  17
175A:  BCF    03.6
175B:  MOVF   3E,W
175C:  BSF    03.6
175D:  MOVWF  16
175E:  BCF    03.6
175F:  MOVF   3D,W
1760:  BSF    03.6
1761:  MOVWF  15
1762:  BCF    03.6
1763:  MOVF   3C,W
1764:  BSF    03.6
1765:  MOVWF  14
1766:  BCF    0A.4
1767:  BCF    03.5
1768:  BCF    03.6
1769:  CALL   533
176A:  BSF    0A.4
176B:  MOVF   7A,W
176C:  BSF    03.6
176D:  MOVWF  46
176E:  MOVF   79,W
176F:  MOVWF  45
1770:  MOVF   78,W
1771:  MOVWF  44
1772:  MOVF   77,W
1773:  MOVWF  43
1774:  MOVLW  48
1775:  BSF    03.5
1776:  MOVWF  13
1777:  MOVLW  E1
1778:  MOVWF  12
1779:  MOVLW  7A
177A:  MOVWF  11
177B:  MOVLW  7E
177C:  MOVWF  10
177D:  BCF    03.6
177E:  MOVF   43,W
177F:  BSF    03.6
1780:  MOVWF  17
1781:  BCF    03.6
1782:  MOVF   42,W
1783:  BSF    03.6
1784:  MOVWF  16
1785:  BCF    03.6
1786:  MOVF   41,W
1787:  BSF    03.6
1788:  MOVWF  15
1789:  BCF    03.6
178A:  MOVF   40,W
178B:  BSF    03.6
178C:  MOVWF  14
178D:  BCF    0A.4
178E:  BCF    03.5
178F:  BCF    03.6
1790:  CALL   533
1791:  BSF    0A.4
1792:  BCF    03.1
1793:  CLRF   2B
1794:  BTFSC  0B.7
1795:  BSF    2B.7
1796:  BCF    0B.7
1797:  BSF    03.6
1798:  MOVF   46,W
1799:  BSF    03.5
179A:  MOVWF  27
179B:  BCF    03.5
179C:  MOVF   45,W
179D:  BSF    03.5
179E:  MOVWF  26
179F:  BCF    03.5
17A0:  MOVF   44,W
17A1:  BSF    03.5
17A2:  MOVWF  25
17A3:  BCF    03.5
17A4:  MOVF   43,W
17A5:  BSF    03.5
17A6:  MOVWF  24
17A7:  MOVF   7A,W
17A8:  MOVWF  2B
17A9:  MOVF   79,W
17AA:  MOVWF  2A
17AB:  MOVF   78,W
17AC:  MOVWF  29
17AD:  MOVF   77,W
17AE:  MOVWF  28
17AF:  BCF    0A.4
17B0:  BCF    03.5
17B1:  BCF    03.6
17B2:  CALL   058
17B3:  BSF    0A.4
17B4:  BTFSC  2B.7
17B5:  BSF    0B.7
17B6:  MOVF   7A,W
17B7:  BSF    03.5
17B8:  MOVWF  47
17B9:  MOVF   79,W
17BA:  MOVWF  46
17BB:  MOVF   78,W
17BC:  MOVWF  45
17BD:  MOVF   77,W
17BE:  MOVWF  44
....................           
....................          inputt = compfilterAngleX; 
17BF:  MOVF   47,W
17C0:  MOVWF  23
17C1:  MOVF   46,W
17C2:  MOVWF  22
17C3:  MOVF   45,W
17C4:  MOVWF  21
17C5:  MOVF   44,W
17C6:  MOVWF  20
17C7:  BCF    03.5
17C8:  BSF    03.6
....................       } 
17C9:  BSF    03.5
17CA:  BCF    03.6
17CB:  GOTO   1DF
....................  
....................       // ! output = pid (inputt) ; 
....................    }//endwhile 
.................... }//endvoidmain 
....................  
17CC:  SLEEP
.................... double pid(DOUBLE inputtt) 
.................... { 
....................    DOUBLE error = (inputtt - setpoint); 
....................    iterm += (ki * error) ; 
....................     
....................    IF (iterm > 250) iterm = 250; 
....................    else IF (iterm < 0) iterm = 0; 
....................     
....................    DOUBLE dinput = (inputtt - lastinput) ; 
....................     
....................    lastinput = inputtt; 
....................    DOUBLE outputt = (kp * error) + 0 - (kd * dinput) / 100; 
....................     
....................    IF (outputt > 250) outputt = 250; 
....................    else IF (outputt < - 250) outputt = - 250; 
....................    RETURN outputt; 
.................... } 
....................  
.................... unsigned INT move(double speed, int minabsspeed) 
.................... { 
....................    dir = 1; 
....................  
....................    IF (speed < 0) 
....................    { 
....................       dir = 2; 
....................       speed -= 30; 
....................    } 
....................  
....................    ELSE speed += 30; 
....................     
....................    IF ( (inputt >= 230)|| (inputt <= 130)|| ( (abs (inputt - setpoint)) <= 0.5)) 
....................    { 
....................       speed = 0; dir = 1; 
....................    } 
....................  
....................    UNSIGNED int realspeed = (int) abs (speed); 
....................     
....................    IF (abs (speed) > 250) realspeed = 250; 
....................    else IF (abs (speed) < minabsspeed) realspeed = minabsspeed; 
....................    //IF (dir == 2) d = - 1 * realspeed; else if (dir == 1) d = realspeed; 
....................     
....................    IF (! (dir == predir)) 
....................    { 
....................       output_high (PIN_A1); output_high (PIN_A3); //output low duty 250 forward 
....................       set_pwm1_duty (250); set_pwm2_duty (250) ; 
....................       predir = dir; 
....................  
....................       IF (dir == 2) 
....................       { 
....................          output_high (PIN_A1); 
....................          output_high (PIN_A3); //output low duty 250 forward 
....................       } else IF (dir == 1) 
....................  
....................       { 
....................    output_low (PIN_A1); 
....................    output_low (PIN_A3); //output low duty 250 forward 
....................       } 
....................    } 
....................  
....................    IF (dir == 1) //forward angle < 180 
....................    { 
....................       set_pwm1_duty (realspeed); 
....................       set_pwm2_duty (realspeed); 
....................    } 
....................  
....................    else IF (dir == 2) 
....................    { 
....................       set_pwm1_duty (250 - realspeed) ; 
....................       set_pwm2_duty (250 - realspeed) ; 
....................    } 
....................  
....................    RETURN realspeed; 
.................... } 
....................  

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
